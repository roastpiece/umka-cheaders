// Generated using umka-cheaders (https://github.com/roastpiece/umka-cheaders)
type Vector2* = struct {
    x: real32
    y: real32
}
type Vector3* = struct {
    x: real32
    y: real32
    z: real32
}
type Vector4* = struct {
    x: real32
    y: real32
    z: real32
    w: real32
}
type Quaternion* = Vector4
type Matrix* = struct {
    m0: real32
    m4: real32
    m8: real32
    m12: real32
    m1: real32
    m5: real32
    m9: real32
    m13: real32
    m2: real32
    m6: real32
    m10: real32
    m14: real32
    m3: real32
    m7: real32
    m11: real32
    m15: real32
}
type Color* = struct {
    r: uint8
    g: uint8
    b: uint8
    a: uint8
}
type Rectangle* = struct {
    x: real32
    y: real32
    width: real32
    height: real32
}
type Image* = struct {
    data: ^void
    width: int32
    height: int32
    mipmaps: int32
    format: int32
}
type Texture* = struct {
    id: uint32
    width: int32
    height: int32
    mipmaps: int32
    format: int32
}
type Texture2D* = Texture
type TextureCubemap* = Texture
type RenderTexture* = struct {
    id: uint32
    texture: Texture
    depth: Texture
}
type RenderTexture2D* = RenderTexture
type NPatchInfo* = struct {
    source: Rectangle
    left: int32
    top: int32
    right: int32
    bottom: int32
    layout: int32
}
type GlyphInfo* = struct {
    value: int32
    offsetX: int32
    offsetY: int32
    advanceX: int32
    image: Image
}
type Font* = struct {
    baseSize: int32
    glyphCount: int32
    glyphPadding: int32
    texture: Texture2D
    recs: ^Rectangle
    glyphs: ^GlyphInfo
}
type Camera3D* = struct {
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: real32
    projection: int32
}
type Camera* = Camera3D
type Camera2D* = struct {
    offset: Vector2
    target: Vector2
    rotation: real32
    zoom: real32
}
type Mesh* = struct {
    vertexCount: int32
    triangleCount: int32
    vertices: ^real32
    texcoords: ^real32
    texcoords2: ^real32
    normals: ^real32
    tangents: ^real32
    colors: str
    indices: ^uint16
    animVertices: ^real32
    animNormals: ^real32
    boneIds: str
    boneWeights: ^real32
    boneMatrices: ^Matrix
    boneCount: int32
    vaoId: uint32
    vboId: ^uint32
}
type Shader* = struct {
    id: uint32
    locs: ^int32
}
type MaterialMap* = struct {
    texture: Texture2D
    color: Color
    value: real32
}
type Material* = struct {
    shader: Shader
    maps: ^MaterialMap
    params: [4]real32
}
type Transform* = struct {
    translation: Vector3
    rotation: Quaternion
    scale: Vector3
}
type BoneInfo* = struct {
    name: [32]int8
    parent: int32
}
type Model* = struct {
    transform: Matrix
    meshCount: int32
    materialCount: int32
    meshes: ^Mesh
    materials: ^Material
    meshMaterial: ^int32
    boneCount: int32
    bones: ^BoneInfo
    bindPose: ^Transform
}
type ModelAnimation* = struct {
    boneCount: int32
    frameCount: int32
    bones: ^BoneInfo
    framePoses: ^^Transform
    name: [32]int8
}
type Ray* = struct {
    position: Vector3
    direction: Vector3
}
type RayCollision* = struct {
    hit: bool
    distance: real32
    point: Vector3
    normal: Vector3
}
type BoundingBox* = struct {
    min: Vector3
    max: Vector3
}
type Wave* = struct {
    frameCount: uint32
    sampleRate: uint32
    sampleSize: uint32
    channels: uint32
    data: ^void
}
type rAudioBuffer* = struct {
}
type rAudioProcessor* = struct {
}
type AudioStream* = struct {
    buffer: ^rAudioBuffer
    processor: ^rAudioProcessor
    sampleRate: uint32
    sampleSize: uint32
    channels: uint32
}
type Sound* = struct {
    stream: AudioStream
    frameCount: uint32
}
type Music* = struct {
    stream: AudioStream
    frameCount: uint32
    looping: bool
    ctxType: int32
    ctxData: ^void
}
type VrDeviceInfo* = struct {
    hResolution: int32
    vResolution: int32
    hScreenSize: real32
    vScreenSize: real32
    eyeToScreenDistance: real32
    lensSeparationDistance: real32
    interpupillaryDistance: real32
    lensDistortionValues: [4]real32
    chromaAbCorrection: [4]real32
}
type VrStereoConfig* = struct {
    projection: [2]Matrix
    viewOffset: [2]Matrix
    leftLensCenter: [2]real32
    rightLensCenter: [2]real32
    leftScreenCenter: [2]real32
    rightScreenCenter: [2]real32
    scale: [2]real32
    scaleIn: [2]real32
}
type FilePathList* = struct {
    capacity: uint32
    count: uint32
    paths: ^str
}
type AutomationEvent* = struct {
    frame: uint32
    __type: uint32
    params: [4]int32
}
type AutomationEventList* = struct {
    capacity: uint32
    count: uint32
    events: ^AutomationEvent
}
type ConfigFlags* = enum {
    FLAG_VSYNC_HINT = 64
    FLAG_FULLSCREEN_MODE = 2
    FLAG_WINDOW_RESIZABLE = 4
    FLAG_WINDOW_UNDECORATED = 8
    FLAG_WINDOW_HIDDEN = 128
    FLAG_WINDOW_MINIMIZED = 512
    FLAG_WINDOW_MAXIMIZED = 1024
    FLAG_WINDOW_UNFOCUSED = 2048
    FLAG_WINDOW_TOPMOST = 4096
    FLAG_WINDOW_ALWAYS_RUN = 256
    FLAG_WINDOW_TRANSPARENT = 16
    FLAG_WINDOW_HIGHDPI = 8192
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
    FLAG_BORDERLESS_WINDOWED_MODE = 32768
    FLAG_MSAA_4X_HINT = 32
    FLAG_INTERLACED_HINT = 65536
}
type TraceLogLevel* = enum {
    LOG_ALL = 0
    LOG_TRACE
    LOG_DEBUG
    LOG_INFO
    LOG_WARNING
    LOG_ERROR
    LOG_FATAL
    LOG_NONE
}
type KeyboardKey* = enum {
    KEY_NULL = 0
    KEY_APOSTROPHE = 39
    KEY_COMMA = 44
    KEY_MINUS = 45
    KEY_PERIOD = 46
    KEY_SLASH = 47
    KEY_ZERO = 48
    KEY_ONE = 49
    KEY_TWO = 50
    KEY_THREE = 51
    KEY_FOUR = 52
    KEY_FIVE = 53
    KEY_SIX = 54
    KEY_SEVEN = 55
    KEY_EIGHT = 56
    KEY_NINE = 57
    KEY_SEMICOLON = 59
    KEY_EQUAL = 61
    KEY_A = 65
    KEY_B = 66
    KEY_C = 67
    KEY_D = 68
    KEY_E = 69
    KEY_F = 70
    KEY_G = 71
    KEY_H = 72
    KEY_I = 73
    KEY_J = 74
    KEY_K = 75
    KEY_L = 76
    KEY_M = 77
    KEY_N = 78
    KEY_O = 79
    KEY_P = 80
    KEY_Q = 81
    KEY_R = 82
    KEY_S = 83
    KEY_T = 84
    KEY_U = 85
    KEY_V = 86
    KEY_W = 87
    KEY_X = 88
    KEY_Y = 89
    KEY_Z = 90
    KEY_LEFT_BRACKET = 91
    KEY_BACKSLASH = 92
    KEY_RIGHT_BRACKET = 93
    KEY_GRAVE = 96
    KEY_SPACE = 32
    KEY_ESCAPE = 256
    KEY_ENTER = 257
    KEY_TAB = 258
    KEY_BACKSPACE = 259
    KEY_INSERT = 260
    KEY_DELETE = 261
    KEY_RIGHT = 262
    KEY_LEFT = 263
    KEY_DOWN = 264
    KEY_UP = 265
    KEY_PAGE_UP = 266
    KEY_PAGE_DOWN = 267
    KEY_HOME = 268
    KEY_END = 269
    KEY_CAPS_LOCK = 280
    KEY_SCROLL_LOCK = 281
    KEY_NUM_LOCK = 282
    KEY_PRINT_SCREEN = 283
    KEY_PAUSE = 284
    KEY_F1 = 290
    KEY_F2 = 291
    KEY_F3 = 292
    KEY_F4 = 293
    KEY_F5 = 294
    KEY_F6 = 295
    KEY_F7 = 296
    KEY_F8 = 297
    KEY_F9 = 298
    KEY_F10 = 299
    KEY_F11 = 300
    KEY_F12 = 301
    KEY_LEFT_SHIFT = 340
    KEY_LEFT_CONTROL = 341
    KEY_LEFT_ALT = 342
    KEY_LEFT_SUPER = 343
    KEY_RIGHT_SHIFT = 344
    KEY_RIGHT_CONTROL = 345
    KEY_RIGHT_ALT = 346
    KEY_RIGHT_SUPER = 347
    KEY_KB_MENU = 348
    KEY_KP_0 = 320
    KEY_KP_1 = 321
    KEY_KP_2 = 322
    KEY_KP_3 = 323
    KEY_KP_4 = 324
    KEY_KP_5 = 325
    KEY_KP_6 = 326
    KEY_KP_7 = 327
    KEY_KP_8 = 328
    KEY_KP_9 = 329
    KEY_KP_DECIMAL = 330
    KEY_KP_DIVIDE = 331
    KEY_KP_MULTIPLY = 332
    KEY_KP_SUBTRACT = 333
    KEY_KP_ADD = 334
    KEY_KP_ENTER = 335
    KEY_KP_EQUAL = 336
    KEY_BACK = 4
    KEY_MENU = 5
    KEY_VOLUME_UP = 24
    KEY_VOLUME_DOWN = 25
}
type MouseButton* = enum {
    MOUSE_BUTTON_LEFT = 0
    MOUSE_BUTTON_RIGHT = 1
    MOUSE_BUTTON_MIDDLE = 2
    MOUSE_BUTTON_SIDE = 3
    MOUSE_BUTTON_EXTRA = 4
    MOUSE_BUTTON_FORWARD = 5
    MOUSE_BUTTON_BACK = 6
}
type MouseCursor* = enum {
    MOUSE_CURSOR_DEFAULT = 0
    MOUSE_CURSOR_ARROW = 1
    MOUSE_CURSOR_IBEAM = 2
    MOUSE_CURSOR_CROSSHAIR = 3
    MOUSE_CURSOR_POINTING_HAND = 4
    MOUSE_CURSOR_RESIZE_EW = 5
    MOUSE_CURSOR_RESIZE_NS = 6
    MOUSE_CURSOR_RESIZE_NWSE = 7
    MOUSE_CURSOR_RESIZE_NESW = 8
    MOUSE_CURSOR_RESIZE_ALL = 9
    MOUSE_CURSOR_NOT_ALLOWED = 10
}
type GamepadButton* = enum {
    GAMEPAD_BUTTON_UNKNOWN = 0
    GAMEPAD_BUTTON_LEFT_FACE_UP
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT
    GAMEPAD_BUTTON_LEFT_FACE_DOWN
    GAMEPAD_BUTTON_LEFT_FACE_LEFT
    GAMEPAD_BUTTON_RIGHT_FACE_UP
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT
    GAMEPAD_BUTTON_LEFT_TRIGGER_1
    GAMEPAD_BUTTON_LEFT_TRIGGER_2
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2
    GAMEPAD_BUTTON_MIDDLE_LEFT
    GAMEPAD_BUTTON_MIDDLE
    GAMEPAD_BUTTON_MIDDLE_RIGHT
    GAMEPAD_BUTTON_LEFT_THUMB
    GAMEPAD_BUTTON_RIGHT_THUMB
}
type GamepadAxis* = enum {
    GAMEPAD_AXIS_LEFT_X = 0
    GAMEPAD_AXIS_LEFT_Y = 1
    GAMEPAD_AXIS_RIGHT_X = 2
    GAMEPAD_AXIS_RIGHT_Y = 3
    GAMEPAD_AXIS_LEFT_TRIGGER = 4
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5
}
type MaterialMapIndex* = enum {
    MATERIAL_MAP_ALBEDO = 0
    MATERIAL_MAP_METALNESS
    MATERIAL_MAP_NORMAL
    MATERIAL_MAP_ROUGHNESS
    MATERIAL_MAP_OCCLUSION
    MATERIAL_MAP_EMISSION
    MATERIAL_MAP_HEIGHT
    MATERIAL_MAP_CUBEMAP
    MATERIAL_MAP_IRRADIANCE
    MATERIAL_MAP_PREFILTER
    MATERIAL_MAP_BRDF
}
type ShaderLocationIndex* = enum {
    SHADER_LOC_VERTEX_POSITION = 0
    SHADER_LOC_VERTEX_TEXCOORD01
    SHADER_LOC_VERTEX_TEXCOORD02
    SHADER_LOC_VERTEX_NORMAL
    SHADER_LOC_VERTEX_TANGENT
    SHADER_LOC_VERTEX_COLOR
    SHADER_LOC_MATRIX_MVP
    SHADER_LOC_MATRIX_VIEW
    SHADER_LOC_MATRIX_PROJECTION
    SHADER_LOC_MATRIX_MODEL
    SHADER_LOC_MATRIX_NORMAL
    SHADER_LOC_VECTOR_VIEW
    SHADER_LOC_COLOR_DIFFUSE
    SHADER_LOC_COLOR_SPECULAR
    SHADER_LOC_COLOR_AMBIENT
    SHADER_LOC_MAP_ALBEDO
    SHADER_LOC_MAP_METALNESS
    SHADER_LOC_MAP_NORMAL
    SHADER_LOC_MAP_ROUGHNESS
    SHADER_LOC_MAP_OCCLUSION
    SHADER_LOC_MAP_EMISSION
    SHADER_LOC_MAP_HEIGHT
    SHADER_LOC_MAP_CUBEMAP
    SHADER_LOC_MAP_IRRADIANCE
    SHADER_LOC_MAP_PREFILTER
    SHADER_LOC_MAP_BRDF
    SHADER_LOC_VERTEX_BONEIDS
    SHADER_LOC_VERTEX_BONEWEIGHTS
    SHADER_LOC_BONE_MATRICES
}
type ShaderUniformDataType* = enum {
    SHADER_UNIFORM_FLOAT = 0
    SHADER_UNIFORM_VEC2
    SHADER_UNIFORM_VEC3
    SHADER_UNIFORM_VEC4
    SHADER_UNIFORM_INT
    SHADER_UNIFORM_IVEC2
    SHADER_UNIFORM_IVEC3
    SHADER_UNIFORM_IVEC4
    SHADER_UNIFORM_SAMPLER2D
}
type ShaderAttributeDataType* = enum {
    SHADER_ATTRIB_FLOAT = 0
    SHADER_ATTRIB_VEC2
    SHADER_ATTRIB_VEC3
    SHADER_ATTRIB_VEC4
}
type PixelFormat* = enum {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA
    PIXELFORMAT_UNCOMPRESSED_R5G6B5
    PIXELFORMAT_UNCOMPRESSED_R8G8B8
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8
    PIXELFORMAT_UNCOMPRESSED_R32
    PIXELFORMAT_UNCOMPRESSED_R32G32B32
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32
    PIXELFORMAT_UNCOMPRESSED_R16
    PIXELFORMAT_UNCOMPRESSED_R16G16B16
    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16
    PIXELFORMAT_COMPRESSED_DXT1_RGB
    PIXELFORMAT_COMPRESSED_DXT1_RGBA
    PIXELFORMAT_COMPRESSED_DXT3_RGBA
    PIXELFORMAT_COMPRESSED_DXT5_RGBA
    PIXELFORMAT_COMPRESSED_ETC1_RGB
    PIXELFORMAT_COMPRESSED_ETC2_RGB
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA
    PIXELFORMAT_COMPRESSED_PVRT_RGB
    PIXELFORMAT_COMPRESSED_PVRT_RGBA
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA
}
type TextureFilter* = enum {
    TEXTURE_FILTER_POINT = 0
    TEXTURE_FILTER_BILINEAR
    TEXTURE_FILTER_TRILINEAR
    TEXTURE_FILTER_ANISOTROPIC_4X
    TEXTURE_FILTER_ANISOTROPIC_8X
    TEXTURE_FILTER_ANISOTROPIC_16X
}
type TextureWrap* = enum {
    TEXTURE_WRAP_REPEAT = 0
    TEXTURE_WRAP_CLAMP
    TEXTURE_WRAP_MIRROR_REPEAT
    TEXTURE_WRAP_MIRROR_CLAMP
}
type CubemapLayout* = enum {
    CUBEMAP_LAYOUT_AUTO_DETECT = 0
    CUBEMAP_LAYOUT_LINE_VERTICAL
    CUBEMAP_LAYOUT_LINE_HORIZONTAL
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE
}
type FontType* = enum {
    FONT_DEFAULT = 0
    FONT_BITMAP
    FONT_SDF
}
type BlendMode* = enum {
    BLEND_ALPHA = 0
    BLEND_ADDITIVE
    BLEND_MULTIPLIED
    BLEND_ADD_COLORS
    BLEND_SUBTRACT_COLORS
    BLEND_ALPHA_PREMULTIPLY
    BLEND_CUSTOM
    BLEND_CUSTOM_SEPARATE
}
type Gesture* = enum {
    GESTURE_NONE = 0
    GESTURE_TAP = 1
    GESTURE_DOUBLETAP = 2
    GESTURE_HOLD = 4
    GESTURE_DRAG = 8
    GESTURE_SWIPE_RIGHT = 16
    GESTURE_SWIPE_LEFT = 32
    GESTURE_SWIPE_UP = 64
    GESTURE_SWIPE_DOWN = 128
    GESTURE_PINCH_IN = 256
    GESTURE_PINCH_OUT = 512
}
type CameraMode* = enum {
    CAMERA_CUSTOM = 0
    CAMERA_FREE
    CAMERA_ORBITAL
    CAMERA_FIRST_PERSON
    CAMERA_THIRD_PERSON
}
type CameraProjection* = enum {
    CAMERA_PERSPECTIVE = 0
    CAMERA_ORTHOGRAPHIC
}
type NPatchLayout* = enum {
    NPATCH_NINE_PATCH = 0
    NPATCH_THREE_PATCH_VERTICAL
    NPATCH_THREE_PATCH_HORIZONTAL
}
ffi fn InitWindow*(width: int32, height: int32, title: str);
ffi fn CloseWindow*();
ffi fn WindowShouldClose*(): bool;
ffi fn IsWindowReady*(): bool;
ffi fn IsWindowFullscreen*(): bool;
ffi fn IsWindowHidden*(): bool;
ffi fn IsWindowMinimized*(): bool;
ffi fn IsWindowMaximized*(): bool;
ffi fn IsWindowFocused*(): bool;
ffi fn IsWindowResized*(): bool;
ffi fn IsWindowState*(flag: uint32): bool;
ffi fn SetWindowState*(flags: uint32);
ffi fn ClearWindowState*(flags: uint32);
ffi fn ToggleFullscreen*();
ffi fn ToggleBorderlessWindowed*();
ffi fn MaximizeWindow*();
ffi fn MinimizeWindow*();
ffi fn RestoreWindow*();
ffi fn SetWindowIcon*(image: Image);
ffi fn SetWindowIcons*(images: ^Image, count: int32);
ffi fn SetWindowTitle*(title: str);
ffi fn SetWindowPosition*(x: int32, y: int32);
ffi fn SetWindowMonitor*(monitor: int32);
ffi fn SetWindowMinSize*(width: int32, height: int32);
ffi fn SetWindowMaxSize*(width: int32, height: int32);
ffi fn SetWindowSize*(width: int32, height: int32);
ffi fn SetWindowOpacity*(opacity: real32);
ffi fn SetWindowFocused*();
ffi fn GetWindowHandle*(): ^void;
ffi fn GetScreenWidth*(): int32;
ffi fn GetScreenHeight*(): int32;
ffi fn GetRenderWidth*(): int32;
ffi fn GetRenderHeight*(): int32;
ffi fn GetMonitorCount*(): int32;
ffi fn GetCurrentMonitor*(): int32;
ffi fn GetMonitorPosition*(monitor: int32): Vector2;
ffi fn GetMonitorWidth*(monitor: int32): int32;
ffi fn GetMonitorHeight*(monitor: int32): int32;
ffi fn GetMonitorPhysicalWidth*(monitor: int32): int32;
ffi fn GetMonitorPhysicalHeight*(monitor: int32): int32;
ffi fn GetMonitorRefreshRate*(monitor: int32): int32;
ffi fn GetWindowPosition*(): Vector2;
ffi fn GetWindowScaleDPI*(): Vector2;
ffi fn GetMonitorName*(monitor: int32): str;
ffi fn SetClipboardText*(text: str);
ffi fn GetClipboardText*(): str;
ffi fn GetClipboardImage*(): Image;
ffi fn EnableEventWaiting*();
ffi fn DisableEventWaiting*();
ffi fn ShowCursor*();
ffi fn HideCursor*();
ffi fn IsCursorHidden*(): bool;
ffi fn EnableCursor*();
ffi fn DisableCursor*();
ffi fn IsCursorOnScreen*(): bool;
ffi fn ClearBackground*(color: Color);
ffi fn BeginDrawing*();
ffi fn EndDrawing*();
ffi fn BeginMode2D*(camera: Camera2D);
ffi fn EndMode2D*();
ffi fn BeginMode3D*(camera: Camera3D);
ffi fn EndMode3D*();
ffi fn BeginTextureMode*(target: RenderTexture2D);
ffi fn EndTextureMode*();
ffi fn BeginShaderMode*(shader: Shader);
ffi fn EndShaderMode*();
ffi fn BeginBlendMode*(mode: int32);
ffi fn EndBlendMode*();
ffi fn BeginScissorMode*(x: int32, y: int32, width: int32, height: int32);
ffi fn EndScissorMode*();
ffi fn BeginVrStereoMode*(config: VrStereoConfig);
ffi fn EndVrStereoMode*();
ffi fn LoadVrStereoConfig*(device: VrDeviceInfo): VrStereoConfig;
ffi fn UnloadVrStereoConfig*(config: VrStereoConfig);
ffi fn LoadShader*(vsFileName: str, fsFileName: str): Shader;
ffi fn LoadShaderFromMemory*(vsCode: str, fsCode: str): Shader;
ffi fn IsShaderValid*(shader: Shader): bool;
ffi fn GetShaderLocation*(shader: Shader, uniformName: str): int32;
ffi fn GetShaderLocationAttrib*(shader: Shader, attribName: str): int32;
ffi fn SetShaderValue*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32);
ffi fn SetShaderValueV*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32, count: int32);
ffi fn SetShaderValueMatrix*(shader: Shader, locIndex: int32, mat: Matrix);
ffi fn SetShaderValueTexture*(shader: Shader, locIndex: int32, texture: Texture2D);
ffi fn UnloadShader*(shader: Shader);
ffi fn GetScreenToWorldRay*(position: Vector2, camera: Camera): Ray;
ffi fn GetScreenToWorldRayEx*(position: Vector2, camera: Camera, width: int32, height: int32): Ray;
ffi fn GetWorldToScreen*(position: Vector3, camera: Camera): Vector2;
ffi fn GetWorldToScreenEx*(position: Vector3, camera: Camera, width: int32, height: int32): Vector2;
ffi fn GetWorldToScreen2D*(position: Vector2, camera: Camera2D): Vector2;
ffi fn GetScreenToWorld2D*(position: Vector2, camera: Camera2D): Vector2;
ffi fn GetCameraMatrix*(camera: Camera): Matrix;
ffi fn GetCameraMatrix2D*(camera: Camera2D): Matrix;
ffi fn SetTargetFPS*(fps: int32);
ffi fn GetFrameTime*(): real32;
ffi fn GetTime*(): real;
ffi fn GetFPS*(): int32;
ffi fn SwapScreenBuffer*();
ffi fn PollInputEvents*();
ffi fn WaitTime*(seconds: real);
ffi fn SetRandomSeed*(seed: uint32);
ffi fn GetRandomValue*(min: int32, max: int32): int32;
ffi fn LoadRandomSequence*(count: uint32, min: int32, max: int32): ^int32;
ffi fn UnloadRandomSequence*(sequence: ^int32);
ffi fn TakeScreenshot*(fileName: str);
ffi fn SetConfigFlags*(flags: uint32);
ffi fn OpenURL*(url: str);
ffi fn SetTraceLogLevel*(logLevel: int32);
ffi fn MemAlloc*(size: uint32): ^void;
ffi fn MemRealloc*(ptr: ^void, size: uint32): ^void;
ffi fn MemFree*(ptr: ^void);
ffi fn LoadFileData*(fileName: str, dataSize: ^int32): str;
ffi fn UnloadFileData*(data: str);
ffi fn SaveFileData*(fileName: str, data: ^void, dataSize: int32): bool;
ffi fn ExportDataAsCode*(data: str, dataSize: int32, fileName: str): bool;
ffi fn LoadFileText*(fileName: str): str;
ffi fn UnloadFileText*(text: str);
ffi fn SaveFileText*(fileName: str, text: str): bool;
ffi fn FileExists*(fileName: str): bool;
ffi fn DirectoryExists*(dirPath: str): bool;
ffi fn IsFileExtension*(fileName: str, ext: str): bool;
ffi fn GetFileLength*(fileName: str): int32;
ffi fn GetFileExtension*(fileName: str): str;
ffi fn GetFileName*(filePath: str): str;
ffi fn GetFileNameWithoutExt*(filePath: str): str;
ffi fn GetDirectoryPath*(filePath: str): str;
ffi fn GetPrevDirectoryPath*(dirPath: str): str;
ffi fn GetWorkingDirectory*(): str;
ffi fn GetApplicationDirectory*(): str;
ffi fn MakeDirectory*(dirPath: str): int32;
ffi fn ChangeDirectory*(dir: str): bool;
ffi fn IsPathFile*(path: str): bool;
ffi fn IsFileNameValid*(fileName: str): bool;
ffi fn LoadDirectoryFiles*(dirPath: str): FilePathList;
ffi fn LoadDirectoryFilesEx*(basePath: str, filter: str, scanSubdirs: bool): FilePathList;
ffi fn UnloadDirectoryFiles*(files: FilePathList);
ffi fn IsFileDropped*(): bool;
ffi fn LoadDroppedFiles*(): FilePathList;
ffi fn UnloadDroppedFiles*(files: FilePathList);
ffi fn GetFileModTime*(fileName: str): int;
ffi fn CompressData*(data: str, dataSize: int32, compDataSize: ^int32): str;
ffi fn DecompressData*(compData: str, compDataSize: int32, dataSize: ^int32): str;
ffi fn EncodeDataBase64*(data: str, dataSize: int32, outputSize: ^int32): str;
ffi fn DecodeDataBase64*(data: str, outputSize: ^int32): str;
ffi fn ComputeCRC32*(data: str, dataSize: int32): uint32;
ffi fn ComputeMD5*(data: str, dataSize: int32): ^uint32;
ffi fn ComputeSHA1*(data: str, dataSize: int32): ^uint32;
ffi fn LoadAutomationEventList*(fileName: str): AutomationEventList;
ffi fn UnloadAutomationEventList*(list: AutomationEventList);
ffi fn ExportAutomationEventList*(list: AutomationEventList, fileName: str): bool;
ffi fn SetAutomationEventList*(list: ^AutomationEventList);
ffi fn SetAutomationEventBaseFrame*(frame: int32);
ffi fn StartAutomationEventRecording*();
ffi fn StopAutomationEventRecording*();
ffi fn PlayAutomationEvent*(event: AutomationEvent);
ffi fn IsKeyPressed*(key: int32): bool;
ffi fn IsKeyPressedRepeat*(key: int32): bool;
ffi fn IsKeyDown*(key: int32): bool;
ffi fn IsKeyReleased*(key: int32): bool;
ffi fn IsKeyUp*(key: int32): bool;
ffi fn GetKeyPressed*(): int32;
ffi fn GetCharPressed*(): int32;
ffi fn SetExitKey*(key: int32);
ffi fn IsGamepadAvailable*(gamepad: int32): bool;
ffi fn GetGamepadName*(gamepad: int32): str;
ffi fn IsGamepadButtonPressed*(gamepad: int32, button: int32): bool;
ffi fn IsGamepadButtonDown*(gamepad: int32, button: int32): bool;
ffi fn IsGamepadButtonReleased*(gamepad: int32, button: int32): bool;
ffi fn IsGamepadButtonUp*(gamepad: int32, button: int32): bool;
ffi fn GetGamepadButtonPressed*(): int32;
ffi fn GetGamepadAxisCount*(gamepad: int32): int32;
ffi fn GetGamepadAxisMovement*(gamepad: int32, axis: int32): real32;
ffi fn SetGamepadMappings*(mappings: str): int32;
ffi fn SetGamepadVibration*(gamepad: int32, leftMotor: real32, rightMotor: real32, duration: real32);
ffi fn IsMouseButtonPressed*(button: int32): bool;
ffi fn IsMouseButtonDown*(button: int32): bool;
ffi fn IsMouseButtonReleased*(button: int32): bool;
ffi fn IsMouseButtonUp*(button: int32): bool;
ffi fn GetMouseX*(): int32;
ffi fn GetMouseY*(): int32;
ffi fn GetMousePosition*(): Vector2;
ffi fn GetMouseDelta*(): Vector2;
ffi fn SetMousePosition*(x: int32, y: int32);
ffi fn SetMouseOffset*(offsetX: int32, offsetY: int32);
ffi fn SetMouseScale*(scaleX: real32, scaleY: real32);
ffi fn GetMouseWheelMove*(): real32;
ffi fn GetMouseWheelMoveV*(): Vector2;
ffi fn SetMouseCursor*(cursor: int32);
ffi fn GetTouchX*(): int32;
ffi fn GetTouchY*(): int32;
ffi fn GetTouchPosition*(index: int32): Vector2;
ffi fn GetTouchPointId*(index: int32): int32;
ffi fn GetTouchPointCount*(): int32;
ffi fn SetGesturesEnabled*(flags: uint32);
ffi fn IsGestureDetected*(gesture: uint32): bool;
ffi fn GetGestureDetected*(): int32;
ffi fn GetGestureHoldDuration*(): real32;
ffi fn GetGestureDragVector*(): Vector2;
ffi fn GetGestureDragAngle*(): real32;
ffi fn GetGesturePinchVector*(): Vector2;
ffi fn GetGesturePinchAngle*(): real32;
ffi fn UpdateCamera*(camera: ^Camera, mode: int32);
ffi fn UpdateCameraPro*(camera: ^Camera, movement: Vector3, rotation: Vector3, zoom: real32);
ffi fn SetShapesTexture*(texture: Texture2D, source: Rectangle);
ffi fn GetShapesTexture*(): Texture2D;
ffi fn GetShapesTextureRectangle*(): Rectangle;
ffi fn DrawPixel*(posX: int32, posY: int32, color: Color);
ffi fn DrawPixelV*(position: Vector2, color: Color);
ffi fn DrawLine*(startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color);
ffi fn DrawLineV*(startPos: Vector2, endPos: Vector2, color: Color);
ffi fn DrawLineEx*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color);
ffi fn DrawLineStrip*(points: ^Vector2, pointCount: int32, color: Color);
ffi fn DrawLineBezier*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color);
ffi fn DrawCircle*(centerX: int32, centerY: int32, radius: real32, color: Color);
ffi fn DrawCircleSector*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
ffi fn DrawCircleSectorLines*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
ffi fn DrawCircleGradient*(centerX: int32, centerY: int32, radius: real32, inner: Color, outer: Color);
ffi fn DrawCircleV*(center: Vector2, radius: real32, color: Color);
ffi fn DrawCircleLines*(centerX: int32, centerY: int32, radius: real32, color: Color);
ffi fn DrawCircleLinesV*(center: Vector2, radius: real32, color: Color);
ffi fn DrawEllipse*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color);
ffi fn DrawEllipseLines*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color);
ffi fn DrawRing*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
ffi fn DrawRingLines*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
ffi fn DrawRectangle*(posX: int32, posY: int32, width: int32, height: int32, color: Color);
ffi fn DrawRectangleV*(position: Vector2, size: Vector2, color: Color);
ffi fn DrawRectangleRec*(rec: Rectangle, color: Color);
ffi fn DrawRectanglePro*(rec: Rectangle, origin: Vector2, rotation: real32, color: Color);
ffi fn DrawRectangleGradientV*(posX: int32, posY: int32, width: int32, height: int32, top: Color, bottom: Color);
ffi fn DrawRectangleGradientH*(posX: int32, posY: int32, width: int32, height: int32, left: Color, right: Color);
ffi fn DrawRectangleGradientEx*(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color);
ffi fn DrawRectangleLines*(posX: int32, posY: int32, width: int32, height: int32, color: Color);
ffi fn DrawRectangleLinesEx*(rec: Rectangle, lineThick: real32, color: Color);
ffi fn DrawRectangleRounded*(rec: Rectangle, roundness: real32, segments: int32, color: Color);
ffi fn DrawRectangleRoundedLines*(rec: Rectangle, roundness: real32, segments: int32, color: Color);
ffi fn DrawRectangleRoundedLinesEx*(rec: Rectangle, roundness: real32, segments: int32, lineThick: real32, color: Color);
ffi fn DrawTriangle*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
ffi fn DrawTriangleLines*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
ffi fn DrawTriangleFan*(points: ^Vector2, pointCount: int32, color: Color);
ffi fn DrawTriangleStrip*(points: ^Vector2, pointCount: int32, color: Color);
ffi fn DrawPoly*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color);
ffi fn DrawPolyLines*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color);
ffi fn DrawPolyLinesEx*(center: Vector2, sides: int32, radius: real32, rotation: real32, lineThick: real32, color: Color);
ffi fn DrawSplineLinear*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
ffi fn DrawSplineBasis*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
ffi fn DrawSplineCatmullRom*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
ffi fn DrawSplineBezierQuadratic*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
ffi fn DrawSplineBezierCubic*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
ffi fn DrawSplineSegmentLinear*(p1: Vector2, p2: Vector2, thick: real32, color: Color);
ffi fn DrawSplineSegmentBasis*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: real32, color: Color);
ffi fn DrawSplineSegmentCatmullRom*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: real32, color: Color);
ffi fn DrawSplineSegmentBezierQuadratic*(p1: Vector2, c2: Vector2, p3: Vector2, thick: real32, color: Color);
ffi fn DrawSplineSegmentBezierCubic*(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: real32, color: Color);
ffi fn GetSplinePointLinear*(startPos: Vector2, endPos: Vector2, t: real32): Vector2;
ffi fn GetSplinePointBasis*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: real32): Vector2;
ffi fn GetSplinePointCatmullRom*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: real32): Vector2;
ffi fn GetSplinePointBezierQuad*(p1: Vector2, c2: Vector2, p3: Vector2, t: real32): Vector2;
ffi fn GetSplinePointBezierCubic*(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: real32): Vector2;
ffi fn CheckCollisionRecs*(rec1: Rectangle, rec2: Rectangle): bool;
ffi fn CheckCollisionCircles*(center1: Vector2, radius1: real32, center2: Vector2, radius2: real32): bool;
ffi fn CheckCollisionCircleRec*(center: Vector2, radius: real32, rec: Rectangle): bool;
ffi fn CheckCollisionCircleLine*(center: Vector2, radius: real32, p1: Vector2, p2: Vector2): bool;
ffi fn CheckCollisionPointRec*(point: Vector2, rec: Rectangle): bool;
ffi fn CheckCollisionPointCircle*(point: Vector2, center: Vector2, radius: real32): bool;
ffi fn CheckCollisionPointTriangle*(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool;
ffi fn CheckCollisionPointLine*(point: Vector2, p1: Vector2, p2: Vector2, threshold: int32): bool;
ffi fn CheckCollisionPointPoly*(point: Vector2, points: ^Vector2, pointCount: int32): bool;
ffi fn CheckCollisionLines*(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2): bool;
ffi fn GetCollisionRec*(rec1: Rectangle, rec2: Rectangle): Rectangle;
ffi fn LoadImage*(fileName: str): Image;
ffi fn LoadImageRaw*(fileName: str, width: int32, height: int32, format: int32, headerSize: int32): Image;
ffi fn LoadImageAnim*(fileName: str, frames: ^int32): Image;
ffi fn LoadImageAnimFromMemory*(fileType: str, fileData: str, dataSize: int32, frames: ^int32): Image;
ffi fn LoadImageFromMemory*(fileType: str, fileData: str, dataSize: int32): Image;
ffi fn LoadImageFromTexture*(texture: Texture2D): Image;
ffi fn LoadImageFromScreen*(): Image;
ffi fn IsImageValid*(image: Image): bool;
ffi fn UnloadImage*(image: Image);
ffi fn ExportImage*(image: Image, fileName: str): bool;
ffi fn ExportImageToMemory*(image: Image, fileType: str, fileSize: ^int32): str;
ffi fn ExportImageAsCode*(image: Image, fileName: str): bool;
ffi fn GenImageColor*(width: int32, height: int32, color: Color): Image;
ffi fn GenImageGradientLinear*(width: int32, height: int32, direction: int32, start: Color, end: Color): Image;
ffi fn GenImageGradientRadial*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image;
ffi fn GenImageGradientSquare*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image;
ffi fn GenImageChecked*(width: int32, height: int32, checksX: int32, checksY: int32, col1: Color, col2: Color): Image;
ffi fn GenImageWhiteNoise*(width: int32, height: int32, factor: real32): Image;
ffi fn GenImagePerlinNoise*(width: int32, height: int32, offsetX: int32, offsetY: int32, scale: real32): Image;
ffi fn GenImageCellular*(width: int32, height: int32, tileSize: int32): Image;
ffi fn GenImageText*(width: int32, height: int32, text: str): Image;
ffi fn ImageCopy*(image: Image): Image;
ffi fn ImageFromImage*(image: Image, rec: Rectangle): Image;
ffi fn ImageFromChannel*(image: Image, selectedChannel: int32): Image;
ffi fn ImageText*(text: str, fontSize: int32, color: Color): Image;
ffi fn ImageTextEx*(font: Font, text: str, fontSize: real32, spacing: real32, tint: Color): Image;
ffi fn ImageFormat*(image: ^Image, newFormat: int32);
ffi fn ImageToPOT*(image: ^Image, fill: Color);
ffi fn ImageCrop*(image: ^Image, crop: Rectangle);
ffi fn ImageAlphaCrop*(image: ^Image, threshold: real32);
ffi fn ImageAlphaClear*(image: ^Image, color: Color, threshold: real32);
ffi fn ImageAlphaMask*(image: ^Image, alphaMask: Image);
ffi fn ImageAlphaPremultiply*(image: ^Image);
ffi fn ImageBlurGaussian*(image: ^Image, blurSize: int32);
ffi fn ImageKernelConvolution*(image: ^Image, kernel: ^real32, kernelSize: int32);
ffi fn ImageResize*(image: ^Image, newWidth: int32, newHeight: int32);
ffi fn ImageResizeNN*(image: ^Image, newWidth: int32, newHeight: int32);
ffi fn ImageResizeCanvas*(image: ^Image, newWidth: int32, newHeight: int32, offsetX: int32, offsetY: int32, fill: Color);
ffi fn ImageMipmaps*(image: ^Image);
ffi fn ImageDither*(image: ^Image, rBpp: int32, gBpp: int32, bBpp: int32, aBpp: int32);
ffi fn ImageFlipVertical*(image: ^Image);
ffi fn ImageFlipHorizontal*(image: ^Image);
ffi fn ImageRotate*(image: ^Image, degrees: int32);
ffi fn ImageRotateCW*(image: ^Image);
ffi fn ImageRotateCCW*(image: ^Image);
ffi fn ImageColorTint*(image: ^Image, color: Color);
ffi fn ImageColorInvert*(image: ^Image);
ffi fn ImageColorGrayscale*(image: ^Image);
ffi fn ImageColorContrast*(image: ^Image, contrast: real32);
ffi fn ImageColorBrightness*(image: ^Image, brightness: int32);
ffi fn ImageColorReplace*(image: ^Image, color: Color, replace: Color);
ffi fn LoadImageColors*(image: Image): ^Color;
ffi fn LoadImagePalette*(image: Image, maxPaletteSize: int32, colorCount: ^int32): ^Color;
ffi fn UnloadImageColors*(colors: ^Color);
ffi fn UnloadImagePalette*(colors: ^Color);
ffi fn GetImageAlphaBorder*(image: Image, threshold: real32): Rectangle;
ffi fn GetImageColor*(image: Image, x: int32, y: int32): Color;
ffi fn ImageClearBackground*(dst: ^Image, color: Color);
ffi fn ImageDrawPixel*(dst: ^Image, posX: int32, posY: int32, color: Color);
ffi fn ImageDrawPixelV*(dst: ^Image, position: Vector2, color: Color);
ffi fn ImageDrawLine*(dst: ^Image, startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color);
ffi fn ImageDrawLineV*(dst: ^Image, start: Vector2, end: Vector2, color: Color);
ffi fn ImageDrawLineEx*(dst: ^Image, start: Vector2, end: Vector2, thick: int32, color: Color);
ffi fn ImageDrawCircle*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color);
ffi fn ImageDrawCircleV*(dst: ^Image, center: Vector2, radius: int32, color: Color);
ffi fn ImageDrawCircleLines*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color);
ffi fn ImageDrawCircleLinesV*(dst: ^Image, center: Vector2, radius: int32, color: Color);
ffi fn ImageDrawRectangle*(dst: ^Image, posX: int32, posY: int32, width: int32, height: int32, color: Color);
ffi fn ImageDrawRectangleV*(dst: ^Image, position: Vector2, size: Vector2, color: Color);
ffi fn ImageDrawRectangleRec*(dst: ^Image, rec: Rectangle, color: Color);
ffi fn ImageDrawRectangleLines*(dst: ^Image, rec: Rectangle, thick: int32, color: Color);
ffi fn ImageDrawTriangle*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
ffi fn ImageDrawTriangleEx*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color);
ffi fn ImageDrawTriangleLines*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
ffi fn ImageDrawTriangleFan*(dst: ^Image, points: ^Vector2, pointCount: int32, color: Color);
ffi fn ImageDrawTriangleStrip*(dst: ^Image, points: ^Vector2, pointCount: int32, color: Color);
ffi fn ImageDraw*(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color);
ffi fn ImageDrawText*(dst: ^Image, text: str, posX: int32, posY: int32, fontSize: int32, color: Color);
ffi fn ImageDrawTextEx*(dst: ^Image, font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
ffi fn LoadTexture*(fileName: str): Texture2D;
ffi fn LoadTextureFromImage*(image: Image): Texture2D;
ffi fn LoadTextureCubemap*(image: Image, layout: int32): TextureCubemap;
ffi fn LoadRenderTexture*(width: int32, height: int32): RenderTexture2D;
ffi fn IsTextureValid*(texture: Texture2D): bool;
ffi fn UnloadTexture*(texture: Texture2D);
ffi fn IsRenderTextureValid*(target: RenderTexture2D): bool;
ffi fn UnloadRenderTexture*(target: RenderTexture2D);
ffi fn UpdateTexture*(texture: Texture2D, pixels: ^void);
ffi fn UpdateTextureRec*(texture: Texture2D, rec: Rectangle, pixels: ^void);
ffi fn GenTextureMipmaps*(texture: ^Texture2D);
ffi fn SetTextureFilter*(texture: Texture2D, filter: int32);
ffi fn SetTextureWrap*(texture: Texture2D, wrap: int32);
ffi fn DrawTexture*(texture: Texture2D, posX: int32, posY: int32, tint: Color);
ffi fn DrawTextureV*(texture: Texture2D, position: Vector2, tint: Color);
ffi fn DrawTextureEx*(texture: Texture2D, position: Vector2, rotation: real32, scale: real32, tint: Color);
ffi fn DrawTextureRec*(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color);
ffi fn DrawTexturePro*(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color);
ffi fn DrawTextureNPatch*(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color);
ffi fn ColorIsEqual*(col1: Color, col2: Color): bool;
ffi fn Fade*(color: Color, alpha: real32): Color;
ffi fn ColorToInt*(color: Color): int32;
ffi fn ColorNormalize*(color: Color): Vector4;
ffi fn ColorFromNormalized*(normalized: Vector4): Color;
ffi fn ColorToHSV*(color: Color): Vector3;
ffi fn ColorFromHSV*(hue: real32, saturation: real32, value: real32): Color;
ffi fn ColorTint*(color: Color, tint: Color): Color;
ffi fn ColorBrightness*(color: Color, factor: real32): Color;
ffi fn ColorContrast*(color: Color, contrast: real32): Color;
ffi fn ColorAlpha*(color: Color, alpha: real32): Color;
ffi fn ColorAlphaBlend*(dst: Color, src: Color, tint: Color): Color;
ffi fn ColorLerp*(color1: Color, color2: Color, factor: real32): Color;
ffi fn GetColor*(hexValue: uint32): Color;
ffi fn GetPixelColor*(srcPtr: ^void, format: int32): Color;
ffi fn SetPixelColor*(dstPtr: ^void, color: Color, format: int32);
ffi fn GetPixelDataSize*(width: int32, height: int32, format: int32): int32;
ffi fn GetFontDefault*(): Font;
ffi fn LoadFont*(fileName: str): Font;
ffi fn LoadFontEx*(fileName: str, fontSize: int32, codepoints: ^int32, codepointCount: int32): Font;
ffi fn LoadFontFromImage*(image: Image, key: Color, firstChar: int32): Font;
ffi fn LoadFontFromMemory*(fileType: str, fileData: str, dataSize: int32, fontSize: int32, codepoints: ^int32, codepointCount: int32): Font;
ffi fn IsFontValid*(font: Font): bool;
ffi fn LoadFontData*(fileData: str, dataSize: int32, fontSize: int32, codepoints: ^int32, codepointCount: int32, __type: int32): ^GlyphInfo;
ffi fn GenImageFontAtlas*(glyphs: ^GlyphInfo, glyphRecs: ^^Rectangle, glyphCount: int32, fontSize: int32, padding: int32, packMethod: int32): Image;
ffi fn UnloadFontData*(glyphs: ^GlyphInfo, glyphCount: int32);
ffi fn UnloadFont*(font: Font);
ffi fn ExportFontAsCode*(font: Font, fileName: str): bool;
ffi fn DrawFPS*(posX: int32, posY: int32);
ffi fn DrawText*(text: str, posX: int32, posY: int32, fontSize: int32, color: Color);
ffi fn DrawTextEx*(font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
ffi fn DrawTextPro*(font: Font, text: str, position: Vector2, origin: Vector2, rotation: real32, fontSize: real32, spacing: real32, tint: Color);
ffi fn DrawTextCodepoint*(font: Font, codepoint: int32, position: Vector2, fontSize: real32, tint: Color);
ffi fn DrawTextCodepoints*(font: Font, codepoints: ^int32, codepointCount: int32, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
ffi fn SetTextLineSpacing*(spacing: int32);
ffi fn MeasureText*(text: str, fontSize: int32): int32;
ffi fn MeasureTextEx*(font: Font, text: str, fontSize: real32, spacing: real32): Vector2;
ffi fn GetGlyphIndex*(font: Font, codepoint: int32): int32;
ffi fn GetGlyphInfo*(font: Font, codepoint: int32): GlyphInfo;
ffi fn GetGlyphAtlasRec*(font: Font, codepoint: int32): Rectangle;
ffi fn LoadUTF8*(codepoints: ^int32, length: int32): str;
ffi fn UnloadUTF8*(text: str);
ffi fn LoadCodepoints*(text: str, count: ^int32): ^int32;
ffi fn UnloadCodepoints*(codepoints: ^int32);
ffi fn GetCodepointCount*(text: str): int32;
ffi fn GetCodepoint*(text: str, codepointSize: ^int32): int32;
ffi fn GetCodepointNext*(text: str, codepointSize: ^int32): int32;
ffi fn GetCodepointPrevious*(text: str, codepointSize: ^int32): int32;
ffi fn CodepointToUTF8*(codepoint: int32, utf8Size: ^int32): str;
ffi fn TextCopy*(dst: str, src: str): int32;
ffi fn TextIsEqual*(text1: str, text2: str): bool;
ffi fn TextLength*(text: str): uint32;
ffi fn TextSubtext*(text: str, position: int32, length: int32): str;
ffi fn TextReplace*(text: str, replace: str, by: str): str;
ffi fn TextInsert*(text: str, insert: str, position: int32): str;
ffi fn TextJoin*(textList: ^str, count: int32, delimiter: str): str;
ffi fn TextSplit*(text: str, delimiter: int8, count: ^int32): ^str;
ffi fn TextAppend*(text: str, append: str, position: ^int32);
ffi fn TextFindIndex*(text: str, find: str): int32;
ffi fn TextToUpper*(text: str): str;
ffi fn TextToLower*(text: str): str;
ffi fn TextToPascal*(text: str): str;
ffi fn TextToSnake*(text: str): str;
ffi fn TextToCamel*(text: str): str;
ffi fn TextToInteger*(text: str): int32;
ffi fn TextToFloat*(text: str): real32;
ffi fn DrawLine3D*(startPos: Vector3, endPos: Vector3, color: Color);
ffi fn DrawPoint3D*(position: Vector3, color: Color);
ffi fn DrawCircle3D*(center: Vector3, radius: real32, rotationAxis: Vector3, rotationAngle: real32, color: Color);
ffi fn DrawTriangle3D*(v1: Vector3, v2: Vector3, v3: Vector3, color: Color);
ffi fn DrawTriangleStrip3D*(points: ^Vector3, pointCount: int32, color: Color);
ffi fn DrawCube*(position: Vector3, width: real32, height: real32, length: real32, color: Color);
ffi fn DrawCubeV*(position: Vector3, size: Vector3, color: Color);
ffi fn DrawCubeWires*(position: Vector3, width: real32, height: real32, length: real32, color: Color);
ffi fn DrawCubeWiresV*(position: Vector3, size: Vector3, color: Color);
ffi fn DrawSphere*(centerPos: Vector3, radius: real32, color: Color);
ffi fn DrawSphereEx*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color);
ffi fn DrawSphereWires*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color);
ffi fn DrawCylinder*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color);
ffi fn DrawCylinderEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color);
ffi fn DrawCylinderWires*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color);
ffi fn DrawCylinderWiresEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color);
ffi fn DrawCapsule*(startPos: Vector3, endPos: Vector3, radius: real32, slices: int32, rings: int32, color: Color);
ffi fn DrawCapsuleWires*(startPos: Vector3, endPos: Vector3, radius: real32, slices: int32, rings: int32, color: Color);
ffi fn DrawPlane*(centerPos: Vector3, size: Vector2, color: Color);
ffi fn DrawRay*(ray: Ray, color: Color);
ffi fn DrawGrid*(slices: int32, spacing: real32);
ffi fn LoadModel*(fileName: str): Model;
ffi fn LoadModelFromMesh*(mesh: Mesh): Model;
ffi fn IsModelValid*(model: Model): bool;
ffi fn UnloadModel*(model: Model);
ffi fn GetModelBoundingBox*(model: Model): BoundingBox;
ffi fn DrawModel*(model: Model, position: Vector3, scale: real32, tint: Color);
ffi fn DrawModelEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
ffi fn DrawModelWires*(model: Model, position: Vector3, scale: real32, tint: Color);
ffi fn DrawModelWiresEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
ffi fn DrawModelPoints*(model: Model, position: Vector3, scale: real32, tint: Color);
ffi fn DrawModelPointsEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
ffi fn DrawBoundingBox*(box: BoundingBox, color: Color);
ffi fn DrawBillboard*(camera: Camera, texture: Texture2D, position: Vector3, scale: real32, tint: Color);
ffi fn DrawBillboardRec*(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color);
ffi fn DrawBillboardPro*(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: real32, tint: Color);
ffi fn UploadMesh*(mesh: ^Mesh, dynamic: bool);
ffi fn UpdateMeshBuffer*(mesh: Mesh, index: int32, data: ^void, dataSize: int32, offset: int32);
ffi fn UnloadMesh*(mesh: Mesh);
ffi fn DrawMesh*(mesh: Mesh, material: Material, transform: Matrix);
ffi fn DrawMeshInstanced*(mesh: Mesh, material: Material, transforms: ^Matrix, instances: int32);
ffi fn GetMeshBoundingBox*(mesh: Mesh): BoundingBox;
ffi fn GenMeshTangents*(mesh: ^Mesh);
ffi fn ExportMesh*(mesh: Mesh, fileName: str): bool;
ffi fn ExportMeshAsCode*(mesh: Mesh, fileName: str): bool;
ffi fn GenMeshPoly*(sides: int32, radius: real32): Mesh;
ffi fn GenMeshPlane*(width: real32, length: real32, resX: int32, resZ: int32): Mesh;
ffi fn GenMeshCube*(width: real32, height: real32, length: real32): Mesh;
ffi fn GenMeshSphere*(radius: real32, rings: int32, slices: int32): Mesh;
ffi fn GenMeshHemiSphere*(radius: real32, rings: int32, slices: int32): Mesh;
ffi fn GenMeshCylinder*(radius: real32, height: real32, slices: int32): Mesh;
ffi fn GenMeshCone*(radius: real32, height: real32, slices: int32): Mesh;
ffi fn GenMeshTorus*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh;
ffi fn GenMeshKnot*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh;
ffi fn GenMeshHeightmap*(heightmap: Image, size: Vector3): Mesh;
ffi fn GenMeshCubicmap*(cubicmap: Image, cubeSize: Vector3): Mesh;
ffi fn LoadMaterials*(fileName: str, materialCount: ^int32): ^Material;
ffi fn LoadMaterialDefault*(): Material;
ffi fn IsMaterialValid*(material: Material): bool;
ffi fn UnloadMaterial*(material: Material);
ffi fn SetMaterialTexture*(material: ^Material, mapType: int32, texture: Texture2D);
ffi fn SetModelMeshMaterial*(model: ^Model, meshId: int32, materialId: int32);
ffi fn LoadModelAnimations*(fileName: str, animCount: ^int32): ^ModelAnimation;
ffi fn UpdateModelAnimation*(model: Model, anim: ModelAnimation, frame: int32);
ffi fn UpdateModelAnimationBones*(model: Model, anim: ModelAnimation, frame: int32);
ffi fn UnloadModelAnimation*(anim: ModelAnimation);
ffi fn UnloadModelAnimations*(animations: ^ModelAnimation, animCount: int32);
ffi fn IsModelAnimationValid*(model: Model, anim: ModelAnimation): bool;
ffi fn CheckCollisionSpheres*(center1: Vector3, radius1: real32, center2: Vector3, radius2: real32): bool;
ffi fn CheckCollisionBoxes*(box1: BoundingBox, box2: BoundingBox): bool;
ffi fn CheckCollisionBoxSphere*(box: BoundingBox, center: Vector3, radius: real32): bool;
ffi fn GetRayCollisionSphere*(ray: Ray, center: Vector3, radius: real32): RayCollision;
ffi fn GetRayCollisionBox*(ray: Ray, box: BoundingBox): RayCollision;
ffi fn GetRayCollisionMesh*(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision;
ffi fn GetRayCollisionTriangle*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision;
ffi fn GetRayCollisionQuad*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision;
ffi fn InitAudioDevice*();
ffi fn CloseAudioDevice*();
ffi fn IsAudioDeviceReady*(): bool;
ffi fn SetMasterVolume*(volume: real32);
ffi fn GetMasterVolume*(): real32;
ffi fn LoadWave*(fileName: str): Wave;
ffi fn LoadWaveFromMemory*(fileType: str, fileData: str, dataSize: int32): Wave;
ffi fn IsWaveValid*(wave: Wave): bool;
ffi fn LoadSound*(fileName: str): Sound;
ffi fn LoadSoundFromWave*(wave: Wave): Sound;
ffi fn LoadSoundAlias*(source: Sound): Sound;
ffi fn IsSoundValid*(sound: Sound): bool;
ffi fn UpdateSound*(sound: Sound, data: ^void, sampleCount: int32);
ffi fn UnloadWave*(wave: Wave);
ffi fn UnloadSound*(sound: Sound);
ffi fn UnloadSoundAlias*(alias: Sound);
ffi fn ExportWave*(wave: Wave, fileName: str): bool;
ffi fn ExportWaveAsCode*(wave: Wave, fileName: str): bool;
ffi fn PlaySound*(sound: Sound);
ffi fn StopSound*(sound: Sound);
ffi fn PauseSound*(sound: Sound);
ffi fn ResumeSound*(sound: Sound);
ffi fn IsSoundPlaying*(sound: Sound): bool;
ffi fn SetSoundVolume*(sound: Sound, volume: real32);
ffi fn SetSoundPitch*(sound: Sound, pitch: real32);
ffi fn SetSoundPan*(sound: Sound, pan: real32);
ffi fn WaveCopy*(wave: Wave): Wave;
ffi fn WaveCrop*(wave: ^Wave, initFrame: int32, finalFrame: int32);
ffi fn WaveFormat*(wave: ^Wave, sampleRate: int32, sampleSize: int32, channels: int32);
ffi fn LoadWaveSamples*(wave: Wave): ^real32;
ffi fn UnloadWaveSamples*(samples: ^real32);
ffi fn LoadMusicStream*(fileName: str): Music;
ffi fn LoadMusicStreamFromMemory*(fileType: str, data: str, dataSize: int32): Music;
ffi fn IsMusicValid*(music: Music): bool;
ffi fn UnloadMusicStream*(music: Music);
ffi fn PlayMusicStream*(music: Music);
ffi fn IsMusicStreamPlaying*(music: Music): bool;
ffi fn UpdateMusicStream*(music: Music);
ffi fn StopMusicStream*(music: Music);
ffi fn PauseMusicStream*(music: Music);
ffi fn ResumeMusicStream*(music: Music);
ffi fn SeekMusicStream*(music: Music, position: real32);
ffi fn SetMusicVolume*(music: Music, volume: real32);
ffi fn SetMusicPitch*(music: Music, pitch: real32);
ffi fn SetMusicPan*(music: Music, pan: real32);
ffi fn GetMusicTimeLength*(music: Music): real32;
ffi fn GetMusicTimePlayed*(music: Music): real32;
ffi fn LoadAudioStream*(sampleRate: uint32, sampleSize: uint32, channels: uint32): AudioStream;
ffi fn IsAudioStreamValid*(stream: AudioStream): bool;
ffi fn UnloadAudioStream*(stream: AudioStream);
ffi fn UpdateAudioStream*(stream: AudioStream, data: ^void, frameCount: int32);
ffi fn IsAudioStreamProcessed*(stream: AudioStream): bool;
ffi fn PlayAudioStream*(stream: AudioStream);
ffi fn PauseAudioStream*(stream: AudioStream);
ffi fn ResumeAudioStream*(stream: AudioStream);
ffi fn IsAudioStreamPlaying*(stream: AudioStream): bool;
ffi fn StopAudioStream*(stream: AudioStream);
ffi fn SetAudioStreamVolume*(stream: AudioStream, volume: real32);
ffi fn SetAudioStreamPitch*(stream: AudioStream, pitch: real32);
ffi fn SetAudioStreamPan*(stream: AudioStream, pan: real32);
ffi fn SetAudioStreamBufferSizeDefault*(size: int32);
