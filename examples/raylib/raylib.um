// Generated using umka-cheaders (https://github.com/roastpiece/umka-cheaders)type Vector2* = struct {
    x: real32
    y: real32
}
type Vector3* = struct {
    x: real32
    y: real32
    z: real32
}
type Vector4* = struct {
    x: real32
    y: real32
    z: real32
    w: real32
}
type Quaternion* = Vector4
type Matrix* = struct {
    m0: real32
    m4: real32
    m8: real32
    m12: real32
    m1: real32
    m5: real32
    m9: real32
    m13: real32
    m2: real32
    m6: real32
    m10: real32
    m14: real32
    m3: real32
    m7: real32
    m11: real32
    m15: real32
}
type Color* = struct {
    r: uint8
    g: uint8
    b: uint8
    a: uint8
}
type Rectangle* = struct {
    x: real32
    y: real32
    width: real32
    height: real32
}
type Image* = struct {
    data: ^void
    width: int32
    height: int32
    mipmaps: int32
    format: int32
}
type Texture* = struct {
    id: uint32
    width: int32
    height: int32
    mipmaps: int32
    format: int32
}
type Texture2D* = Texture
type TextureCubemap* = Texture
type RenderTexture* = struct {
    id: uint32
    texture: Texture
    depth: Texture
}
type RenderTexture2D* = RenderTexture
type NPatchInfo* = struct {
    source: Rectangle
    left: int32
    top: int32
    right: int32
    bottom: int32
    layout: int32
}
type GlyphInfo* = struct {
    value: int32
    offsetX: int32
    offsetY: int32
    advanceX: int32
    image: Image
}
type Font* = struct {
    baseSize: int32
    glyphCount: int32
    glyphPadding: int32
    texture: Texture2D
    recs: ^Rectangle
    glyphs: ^GlyphInfo
}
type Camera3D* = struct {
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: real32
    projection: int32
}
type Camera* = Camera3D
type Camera2D* = struct {
    offset: Vector2
    target: Vector2
    rotation: real32
    zoom: real32
}
type Mesh* = struct {
    vertexCount: int32
    triangleCount: int32
    vertices: ^real32
    texcoords: ^real32
    texcoords2: ^real32
    normals: ^real32
    tangents: ^real32
    colors: str
    indices: ^uint16
    animVertices: ^real32
    animNormals: ^real32
    boneIds: str
    boneWeights: ^real32
    boneMatrices: ^Matrix
    boneCount: int32
    vaoId: uint32
    vboId: ^uint32
}
type Shader* = struct {
    id: uint32
    locs: ^int32
}
type MaterialMap* = struct {
    texture: Texture2D
    color: Color
    value: real32
}
type Material* = struct {
    shader: Shader
    maps: ^MaterialMap
    params: [4]real32
}
type Transform* = struct {
    translation: Vector3
    rotation: Quaternion
    scale: Vector3
}
type BoneInfo* = struct {
    name: [32]int8
    parent: int32
}
type Model* = struct {
    transform: Matrix
    meshCount: int32
    materialCount: int32
    meshes: ^Mesh
    materials: ^Material
    meshMaterial: ^int32
    boneCount: int32
    bones: ^BoneInfo
    bindPose: ^Transform
}
type ModelAnimation* = struct {
    boneCount: int32
    frameCount: int32
    bones: ^BoneInfo
    framePoses: ^^Transform
    name: [32]int8
}
type Ray* = struct {
    position: Vector3
    direction: Vector3
}
type RayCollision* = struct {
    hit: bool
    distance: real32
    point: Vector3
    normal: Vector3
}
type BoundingBox* = struct {
    min: Vector3
    max: Vector3
}
type Wave* = struct {
    frameCount: uint32
    sampleRate: uint32
    sampleSize: uint32
    channels: uint32
    data: ^void
}
type rAudioBuffer* = struct {
}
type rAudioProcessor* = struct {
}
type AudioStream* = struct {
    buffer: ^rAudioBuffer
    processor: ^rAudioProcessor
    sampleRate: uint32
    sampleSize: uint32
    channels: uint32
}
type Sound* = struct {
    stream: AudioStream
    frameCount: uint32
}
type Music* = struct {
    stream: AudioStream
    frameCount: uint32
    looping: bool
    ctxType: int32
    ctxData: ^void
}
type VrDeviceInfo* = struct {
    hResolution: int32
    vResolution: int32
    hScreenSize: real32
    vScreenSize: real32
    eyeToScreenDistance: real32
    lensSeparationDistance: real32
    interpupillaryDistance: real32
    lensDistortionValues: [4]real32
    chromaAbCorrection: [4]real32
}
type VrStereoConfig* = struct {
    projection: [2]Matrix
    viewOffset: [2]Matrix
    leftLensCenter: [2]real32
    rightLensCenter: [2]real32
    leftScreenCenter: [2]real32
    rightScreenCenter: [2]real32
    scale: [2]real32
    scaleIn: [2]real32
}
type FilePathList* = struct {
    capacity: uint32
    count: uint32
    paths: ^str
}
type AutomationEvent* = struct {
    frame: uint32
    __type: uint32
    params: [4]int32
}
type AutomationEventList* = struct {
    capacity: uint32
    count: uint32
    events: ^AutomationEvent
}
type ConfigFlags* = enum {
    FLAG_VSYNC_HINT = 64
    FLAG_FULLSCREEN_MODE = 2
    FLAG_WINDOW_RESIZABLE = 4
    FLAG_WINDOW_UNDECORATED = 8
    FLAG_WINDOW_HIDDEN = 128
    FLAG_WINDOW_MINIMIZED = 512
    FLAG_WINDOW_MAXIMIZED = 1024
    FLAG_WINDOW_UNFOCUSED = 2048
    FLAG_WINDOW_TOPMOST = 4096
    FLAG_WINDOW_ALWAYS_RUN = 256
    FLAG_WINDOW_TRANSPARENT = 16
    FLAG_WINDOW_HIGHDPI = 8192
    FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
    FLAG_BORDERLESS_WINDOWED_MODE = 32768
    FLAG_MSAA_4X_HINT = 32
    FLAG_INTERLACED_HINT = 65536
}
type TraceLogLevel* = enum {
    LOG_ALL = 0
    LOG_TRACE
    LOG_DEBUG
    LOG_INFO
    LOG_WARNING
    LOG_ERROR
    LOG_FATAL
    LOG_NONE
}
type KeyboardKey* = enum {
    KEY_NULL = 0
    KEY_APOSTROPHE = 39
    KEY_COMMA = 44
    KEY_MINUS = 45
    KEY_PERIOD = 46
    KEY_SLASH = 47
    KEY_ZERO = 48
    KEY_ONE = 49
    KEY_TWO = 50
    KEY_THREE = 51
    KEY_FOUR = 52
    KEY_FIVE = 53
    KEY_SIX = 54
    KEY_SEVEN = 55
    KEY_EIGHT = 56
    KEY_NINE = 57
    KEY_SEMICOLON = 59
    KEY_EQUAL = 61
    KEY_A = 65
    KEY_B = 66
    KEY_C = 67
    KEY_D = 68
    KEY_E = 69
    KEY_F = 70
    KEY_G = 71
    KEY_H = 72
    KEY_I = 73
    KEY_J = 74
    KEY_K = 75
    KEY_L = 76
    KEY_M = 77
    KEY_N = 78
    KEY_O = 79
    KEY_P = 80
    KEY_Q = 81
    KEY_R = 82
    KEY_S = 83
    KEY_T = 84
    KEY_U = 85
    KEY_V = 86
    KEY_W = 87
    KEY_X = 88
    KEY_Y = 89
    KEY_Z = 90
    KEY_LEFT_BRACKET = 91
    KEY_BACKSLASH = 92
    KEY_RIGHT_BRACKET = 93
    KEY_GRAVE = 96
    KEY_SPACE = 32
    KEY_ESCAPE = 256
    KEY_ENTER = 257
    KEY_TAB = 258
    KEY_BACKSPACE = 259
    KEY_INSERT = 260
    KEY_DELETE = 261
    KEY_RIGHT = 262
    KEY_LEFT = 263
    KEY_DOWN = 264
    KEY_UP = 265
    KEY_PAGE_UP = 266
    KEY_PAGE_DOWN = 267
    KEY_HOME = 268
    KEY_END = 269
    KEY_CAPS_LOCK = 280
    KEY_SCROLL_LOCK = 281
    KEY_NUM_LOCK = 282
    KEY_PRINT_SCREEN = 283
    KEY_PAUSE = 284
    KEY_F1 = 290
    KEY_F2 = 291
    KEY_F3 = 292
    KEY_F4 = 293
    KEY_F5 = 294
    KEY_F6 = 295
    KEY_F7 = 296
    KEY_F8 = 297
    KEY_F9 = 298
    KEY_F10 = 299
    KEY_F11 = 300
    KEY_F12 = 301
    KEY_LEFT_SHIFT = 340
    KEY_LEFT_CONTROL = 341
    KEY_LEFT_ALT = 342
    KEY_LEFT_SUPER = 343
    KEY_RIGHT_SHIFT = 344
    KEY_RIGHT_CONTROL = 345
    KEY_RIGHT_ALT = 346
    KEY_RIGHT_SUPER = 347
    KEY_KB_MENU = 348
    KEY_KP_0 = 320
    KEY_KP_1 = 321
    KEY_KP_2 = 322
    KEY_KP_3 = 323
    KEY_KP_4 = 324
    KEY_KP_5 = 325
    KEY_KP_6 = 326
    KEY_KP_7 = 327
    KEY_KP_8 = 328
    KEY_KP_9 = 329
    KEY_KP_DECIMAL = 330
    KEY_KP_DIVIDE = 331
    KEY_KP_MULTIPLY = 332
    KEY_KP_SUBTRACT = 333
    KEY_KP_ADD = 334
    KEY_KP_ENTER = 335
    KEY_KP_EQUAL = 336
    KEY_BACK = 4
    KEY_MENU = 5
    KEY_VOLUME_UP = 24
    KEY_VOLUME_DOWN = 25
}
type MouseButton* = enum {
    MOUSE_BUTTON_LEFT = 0
    MOUSE_BUTTON_RIGHT = 1
    MOUSE_BUTTON_MIDDLE = 2
    MOUSE_BUTTON_SIDE = 3
    MOUSE_BUTTON_EXTRA = 4
    MOUSE_BUTTON_FORWARD = 5
    MOUSE_BUTTON_BACK = 6
}
type MouseCursor* = enum {
    MOUSE_CURSOR_DEFAULT = 0
    MOUSE_CURSOR_ARROW = 1
    MOUSE_CURSOR_IBEAM = 2
    MOUSE_CURSOR_CROSSHAIR = 3
    MOUSE_CURSOR_POINTING_HAND = 4
    MOUSE_CURSOR_RESIZE_EW = 5
    MOUSE_CURSOR_RESIZE_NS = 6
    MOUSE_CURSOR_RESIZE_NWSE = 7
    MOUSE_CURSOR_RESIZE_NESW = 8
    MOUSE_CURSOR_RESIZE_ALL = 9
    MOUSE_CURSOR_NOT_ALLOWED = 10
}
type GamepadButton* = enum {
    GAMEPAD_BUTTON_UNKNOWN = 0
    GAMEPAD_BUTTON_LEFT_FACE_UP
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT
    GAMEPAD_BUTTON_LEFT_FACE_DOWN
    GAMEPAD_BUTTON_LEFT_FACE_LEFT
    GAMEPAD_BUTTON_RIGHT_FACE_UP
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT
    GAMEPAD_BUTTON_LEFT_TRIGGER_1
    GAMEPAD_BUTTON_LEFT_TRIGGER_2
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2
    GAMEPAD_BUTTON_MIDDLE_LEFT
    GAMEPAD_BUTTON_MIDDLE
    GAMEPAD_BUTTON_MIDDLE_RIGHT
    GAMEPAD_BUTTON_LEFT_THUMB
    GAMEPAD_BUTTON_RIGHT_THUMB
}
type GamepadAxis* = enum {
    GAMEPAD_AXIS_LEFT_X = 0
    GAMEPAD_AXIS_LEFT_Y = 1
    GAMEPAD_AXIS_RIGHT_X = 2
    GAMEPAD_AXIS_RIGHT_Y = 3
    GAMEPAD_AXIS_LEFT_TRIGGER = 4
    GAMEPAD_AXIS_RIGHT_TRIGGER = 5
}
type MaterialMapIndex* = enum {
    MATERIAL_MAP_ALBEDO = 0
    MATERIAL_MAP_METALNESS
    MATERIAL_MAP_NORMAL
    MATERIAL_MAP_ROUGHNESS
    MATERIAL_MAP_OCCLUSION
    MATERIAL_MAP_EMISSION
    MATERIAL_MAP_HEIGHT
    MATERIAL_MAP_CUBEMAP
    MATERIAL_MAP_IRRADIANCE
    MATERIAL_MAP_PREFILTER
    MATERIAL_MAP_BRDF
}
type ShaderLocationIndex* = enum {
    SHADER_LOC_VERTEX_POSITION = 0
    SHADER_LOC_VERTEX_TEXCOORD01
    SHADER_LOC_VERTEX_TEXCOORD02
    SHADER_LOC_VERTEX_NORMAL
    SHADER_LOC_VERTEX_TANGENT
    SHADER_LOC_VERTEX_COLOR
    SHADER_LOC_MATRIX_MVP
    SHADER_LOC_MATRIX_VIEW
    SHADER_LOC_MATRIX_PROJECTION
    SHADER_LOC_MATRIX_MODEL
    SHADER_LOC_MATRIX_NORMAL
    SHADER_LOC_VECTOR_VIEW
    SHADER_LOC_COLOR_DIFFUSE
    SHADER_LOC_COLOR_SPECULAR
    SHADER_LOC_COLOR_AMBIENT
    SHADER_LOC_MAP_ALBEDO
    SHADER_LOC_MAP_METALNESS
    SHADER_LOC_MAP_NORMAL
    SHADER_LOC_MAP_ROUGHNESS
    SHADER_LOC_MAP_OCCLUSION
    SHADER_LOC_MAP_EMISSION
    SHADER_LOC_MAP_HEIGHT
    SHADER_LOC_MAP_CUBEMAP
    SHADER_LOC_MAP_IRRADIANCE
    SHADER_LOC_MAP_PREFILTER
    SHADER_LOC_MAP_BRDF
    SHADER_LOC_VERTEX_BONEIDS
    SHADER_LOC_VERTEX_BONEWEIGHTS
    SHADER_LOC_BONE_MATRICES
}
type ShaderUniformDataType* = enum {
    SHADER_UNIFORM_FLOAT = 0
    SHADER_UNIFORM_VEC2
    SHADER_UNIFORM_VEC3
    SHADER_UNIFORM_VEC4
    SHADER_UNIFORM_INT
    SHADER_UNIFORM_IVEC2
    SHADER_UNIFORM_IVEC3
    SHADER_UNIFORM_IVEC4
    SHADER_UNIFORM_SAMPLER2D
}
type ShaderAttributeDataType* = enum {
    SHADER_ATTRIB_FLOAT = 0
    SHADER_ATTRIB_VEC2
    SHADER_ATTRIB_VEC3
    SHADER_ATTRIB_VEC4
}
type PixelFormat* = enum {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA
    PIXELFORMAT_UNCOMPRESSED_R5G6B5
    PIXELFORMAT_UNCOMPRESSED_R8G8B8
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8
    PIXELFORMAT_UNCOMPRESSED_R32
    PIXELFORMAT_UNCOMPRESSED_R32G32B32
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32
    PIXELFORMAT_UNCOMPRESSED_R16
    PIXELFORMAT_UNCOMPRESSED_R16G16B16
    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16
    PIXELFORMAT_COMPRESSED_DXT1_RGB
    PIXELFORMAT_COMPRESSED_DXT1_RGBA
    PIXELFORMAT_COMPRESSED_DXT3_RGBA
    PIXELFORMAT_COMPRESSED_DXT5_RGBA
    PIXELFORMAT_COMPRESSED_ETC1_RGB
    PIXELFORMAT_COMPRESSED_ETC2_RGB
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA
    PIXELFORMAT_COMPRESSED_PVRT_RGB
    PIXELFORMAT_COMPRESSED_PVRT_RGBA
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA
}
type TextureFilter* = enum {
    TEXTURE_FILTER_POINT = 0
    TEXTURE_FILTER_BILINEAR
    TEXTURE_FILTER_TRILINEAR
    TEXTURE_FILTER_ANISOTROPIC_4X
    TEXTURE_FILTER_ANISOTROPIC_8X
    TEXTURE_FILTER_ANISOTROPIC_16X
}
type TextureWrap* = enum {
    TEXTURE_WRAP_REPEAT = 0
    TEXTURE_WRAP_CLAMP
    TEXTURE_WRAP_MIRROR_REPEAT
    TEXTURE_WRAP_MIRROR_CLAMP
}
type CubemapLayout* = enum {
    CUBEMAP_LAYOUT_AUTO_DETECT = 0
    CUBEMAP_LAYOUT_LINE_VERTICAL
    CUBEMAP_LAYOUT_LINE_HORIZONTAL
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE
}
type FontType* = enum {
    FONT_DEFAULT = 0
    FONT_BITMAP
    FONT_SDF
}
type BlendMode* = enum {
    BLEND_ALPHA = 0
    BLEND_ADDITIVE
    BLEND_MULTIPLIED
    BLEND_ADD_COLORS
    BLEND_SUBTRACT_COLORS
    BLEND_ALPHA_PREMULTIPLY
    BLEND_CUSTOM
    BLEND_CUSTOM_SEPARATE
}
type Gesture* = enum {
    GESTURE_NONE = 0
    GESTURE_TAP = 1
    GESTURE_DOUBLETAP = 2
    GESTURE_HOLD = 4
    GESTURE_DRAG = 8
    GESTURE_SWIPE_RIGHT = 16
    GESTURE_SWIPE_LEFT = 32
    GESTURE_SWIPE_UP = 64
    GESTURE_SWIPE_DOWN = 128
    GESTURE_PINCH_IN = 256
    GESTURE_PINCH_OUT = 512
}
type CameraMode* = enum {
    CAMERA_CUSTOM = 0
    CAMERA_FREE
    CAMERA_ORBITAL
    CAMERA_FIRST_PERSON
    CAMERA_THIRD_PERSON
}
type CameraProjection* = enum {
    CAMERA_PERSPECTIVE = 0
    CAMERA_ORTHOGRAPHIC
}
type NPatchLayout* = enum {
    NPATCH_NINE_PATCH = 0
    NPATCH_THREE_PATCH_VERTICAL
    NPATCH_THREE_PATCH_HORIZONTAL
}
fn InitWindow*(width: int32, height: int32, title: str);
fn CloseWindow*();
fn WindowShouldClose*(): bool;
fn IsWindowReady*(): bool;
fn IsWindowFullscreen*(): bool;
fn IsWindowHidden*(): bool;
fn IsWindowMinimized*(): bool;
fn IsWindowMaximized*(): bool;
fn IsWindowFocused*(): bool;
fn IsWindowResized*(): bool;
fn IsWindowState*(flag: uint32): bool;
fn SetWindowState*(flags: uint32);
fn ClearWindowState*(flags: uint32);
fn ToggleFullscreen*();
fn ToggleBorderlessWindowed*();
fn MaximizeWindow*();
fn MinimizeWindow*();
fn RestoreWindow*();
fn SetWindowIcon*(image: Image);
fn SetWindowIcons*(images: ^Image, count: int32);
fn SetWindowTitle*(title: str);
fn SetWindowPosition*(x: int32, y: int32);
fn SetWindowMonitor*(monitor: int32);
fn SetWindowMinSize*(width: int32, height: int32);
fn SetWindowMaxSize*(width: int32, height: int32);
fn SetWindowSize*(width: int32, height: int32);
fn SetWindowOpacity*(opacity: real32);
fn SetWindowFocused*();
fn GetWindowHandle*(): ^void;
fn GetScreenWidth*(): int32;
fn GetScreenHeight*(): int32;
fn GetRenderWidth*(): int32;
fn GetRenderHeight*(): int32;
fn GetMonitorCount*(): int32;
fn GetCurrentMonitor*(): int32;
fn GetMonitorPosition*(monitor: int32): Vector2;
fn GetMonitorWidth*(monitor: int32): int32;
fn GetMonitorHeight*(monitor: int32): int32;
fn GetMonitorPhysicalWidth*(monitor: int32): int32;
fn GetMonitorPhysicalHeight*(monitor: int32): int32;
fn GetMonitorRefreshRate*(monitor: int32): int32;
fn GetWindowPosition*(): Vector2;
fn GetWindowScaleDPI*(): Vector2;
fn GetMonitorName*(monitor: int32): str;
fn SetClipboardText*(text: str);
fn GetClipboardText*(): str;
fn GetClipboardImage*(): Image;
fn EnableEventWaiting*();
fn DisableEventWaiting*();
fn ShowCursor*();
fn HideCursor*();
fn IsCursorHidden*(): bool;
fn EnableCursor*();
fn DisableCursor*();
fn IsCursorOnScreen*(): bool;
fn ClearBackground*(color: Color);
fn BeginDrawing*();
fn EndDrawing*();
fn BeginMode2D*(camera: Camera2D);
fn EndMode2D*();
fn BeginMode3D*(camera: Camera3D);
fn EndMode3D*();
fn BeginTextureMode*(target: RenderTexture2D);
fn EndTextureMode*();
fn BeginShaderMode*(shader: Shader);
fn EndShaderMode*();
fn BeginBlendMode*(mode: int32);
fn EndBlendMode*();
fn BeginScissorMode*(x: int32, y: int32, width: int32, height: int32);
fn EndScissorMode*();
fn BeginVrStereoMode*(config: VrStereoConfig);
fn EndVrStereoMode*();
fn LoadVrStereoConfig*(device: VrDeviceInfo): VrStereoConfig;
fn UnloadVrStereoConfig*(config: VrStereoConfig);
fn LoadShader*(vsFileName: str, fsFileName: str): Shader;
fn LoadShaderFromMemory*(vsCode: str, fsCode: str): Shader;
fn IsShaderValid*(shader: Shader): bool;
fn GetShaderLocation*(shader: Shader, uniformName: str): int32;
fn GetShaderLocationAttrib*(shader: Shader, attribName: str): int32;
fn SetShaderValue*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32);
fn SetShaderValueV*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32, count: int32);
fn SetShaderValueMatrix*(shader: Shader, locIndex: int32, mat: Matrix);
fn SetShaderValueTexture*(shader: Shader, locIndex: int32, texture: Texture2D);
fn UnloadShader*(shader: Shader);
fn GetScreenToWorldRay*(position: Vector2, camera: Camera): Ray;
fn GetScreenToWorldRayEx*(position: Vector2, camera: Camera, width: int32, height: int32): Ray;
fn GetWorldToScreen*(position: Vector3, camera: Camera): Vector2;
fn GetWorldToScreenEx*(position: Vector3, camera: Camera, width: int32, height: int32): Vector2;
fn GetWorldToScreen2D*(position: Vector2, camera: Camera2D): Vector2;
fn GetScreenToWorld2D*(position: Vector2, camera: Camera2D): Vector2;
fn GetCameraMatrix*(camera: Camera): Matrix;
fn GetCameraMatrix2D*(camera: Camera2D): Matrix;
fn SetTargetFPS*(fps: int32);
fn GetFrameTime*(): real32;
fn GetTime*(): real;
fn GetFPS*(): int32;
fn SwapScreenBuffer*();
fn PollInputEvents*();
fn WaitTime*(seconds: real);
fn SetRandomSeed*(seed: uint32);
fn GetRandomValue*(min: int32, max: int32): int32;
fn LoadRandomSequence*(count: uint32, min: int32, max: int32): ^int32;
fn UnloadRandomSequence*(sequence: ^int32);
fn TakeScreenshot*(fileName: str);
fn SetConfigFlags*(flags: uint32);
fn OpenURL*(url: str);
fn SetTraceLogLevel*(logLevel: int32);
fn MemAlloc*(size: uint32): ^void;
fn MemRealloc*(ptr: ^void, size: uint32): ^void;
fn MemFree*(ptr: ^void);
fn LoadFileData*(fileName: str, dataSize: ^int32): str;
fn UnloadFileData*(data: str);
fn SaveFileData*(fileName: str, data: ^void, dataSize: int32): bool;
fn ExportDataAsCode*(data: str, dataSize: int32, fileName: str): bool;
fn LoadFileText*(fileName: str): str;
fn UnloadFileText*(text: str);
fn SaveFileText*(fileName: str, text: str): bool;
fn FileExists*(fileName: str): bool;
fn DirectoryExists*(dirPath: str): bool;
fn IsFileExtension*(fileName: str, ext: str): bool;
fn GetFileLength*(fileName: str): int32;
fn GetFileExtension*(fileName: str): str;
fn GetFileName*(filePath: str): str;
fn GetFileNameWithoutExt*(filePath: str): str;
fn GetDirectoryPath*(filePath: str): str;
fn GetPrevDirectoryPath*(dirPath: str): str;
fn GetWorkingDirectory*(): str;
fn GetApplicationDirectory*(): str;
fn MakeDirectory*(dirPath: str): int32;
fn ChangeDirectory*(dir: str): bool;
fn IsPathFile*(path: str): bool;
fn IsFileNameValid*(fileName: str): bool;
fn LoadDirectoryFiles*(dirPath: str): FilePathList;
fn LoadDirectoryFilesEx*(basePath: str, filter: str, scanSubdirs: bool): FilePathList;
fn UnloadDirectoryFiles*(files: FilePathList);
fn IsFileDropped*(): bool;
fn LoadDroppedFiles*(): FilePathList;
fn UnloadDroppedFiles*(files: FilePathList);
fn GetFileModTime*(fileName: str): int;
fn CompressData*(data: str, dataSize: int32, compDataSize: ^int32): str;
fn DecompressData*(compData: str, compDataSize: int32, dataSize: ^int32): str;
fn EncodeDataBase64*(data: str, dataSize: int32, outputSize: ^int32): str;
fn DecodeDataBase64*(data: str, outputSize: ^int32): str;
fn ComputeCRC32*(data: str, dataSize: int32): uint32;
fn ComputeMD5*(data: str, dataSize: int32): ^uint32;
fn ComputeSHA1*(data: str, dataSize: int32): ^uint32;
fn LoadAutomationEventList*(fileName: str): AutomationEventList;
fn UnloadAutomationEventList*(list: AutomationEventList);
fn ExportAutomationEventList*(list: AutomationEventList, fileName: str): bool;
fn SetAutomationEventList*(list: ^AutomationEventList);
fn SetAutomationEventBaseFrame*(frame: int32);
fn StartAutomationEventRecording*();
fn StopAutomationEventRecording*();
fn PlayAutomationEvent*(event: AutomationEvent);
fn IsKeyPressed*(key: int32): bool;
fn IsKeyPressedRepeat*(key: int32): bool;
fn IsKeyDown*(key: int32): bool;
fn IsKeyReleased*(key: int32): bool;
fn IsKeyUp*(key: int32): bool;
fn GetKeyPressed*(): int32;
fn GetCharPressed*(): int32;
fn SetExitKey*(key: int32);
fn IsGamepadAvailable*(gamepad: int32): bool;
fn GetGamepadName*(gamepad: int32): str;
fn IsGamepadButtonPressed*(gamepad: int32, button: int32): bool;
fn IsGamepadButtonDown*(gamepad: int32, button: int32): bool;
fn IsGamepadButtonReleased*(gamepad: int32, button: int32): bool;
fn IsGamepadButtonUp*(gamepad: int32, button: int32): bool;
fn GetGamepadButtonPressed*(): int32;
fn GetGamepadAxisCount*(gamepad: int32): int32;
fn GetGamepadAxisMovement*(gamepad: int32, axis: int32): real32;
fn SetGamepadMappings*(mappings: str): int32;
fn SetGamepadVibration*(gamepad: int32, leftMotor: real32, rightMotor: real32, duration: real32);
fn IsMouseButtonPressed*(button: int32): bool;
fn IsMouseButtonDown*(button: int32): bool;
fn IsMouseButtonReleased*(button: int32): bool;
fn IsMouseButtonUp*(button: int32): bool;
fn GetMouseX*(): int32;
fn GetMouseY*(): int32;
fn GetMousePosition*(): Vector2;
fn GetMouseDelta*(): Vector2;
fn SetMousePosition*(x: int32, y: int32);
fn SetMouseOffset*(offsetX: int32, offsetY: int32);
fn SetMouseScale*(scaleX: real32, scaleY: real32);
fn GetMouseWheelMove*(): real32;
fn GetMouseWheelMoveV*(): Vector2;
fn SetMouseCursor*(cursor: int32);
fn GetTouchX*(): int32;
fn GetTouchY*(): int32;
fn GetTouchPosition*(index: int32): Vector2;
fn GetTouchPointId*(index: int32): int32;
fn GetTouchPointCount*(): int32;
fn SetGesturesEnabled*(flags: uint32);
fn IsGestureDetected*(gesture: uint32): bool;
fn GetGestureDetected*(): int32;
fn GetGestureHoldDuration*(): real32;
fn GetGestureDragVector*(): Vector2;
fn GetGestureDragAngle*(): real32;
fn GetGesturePinchVector*(): Vector2;
fn GetGesturePinchAngle*(): real32;
fn UpdateCamera*(camera: ^Camera, mode: int32);
fn UpdateCameraPro*(camera: ^Camera, movement: Vector3, rotation: Vector3, zoom: real32);
fn SetShapesTexture*(texture: Texture2D, source: Rectangle);
fn GetShapesTexture*(): Texture2D;
fn GetShapesTextureRectangle*(): Rectangle;
fn DrawPixel*(posX: int32, posY: int32, color: Color);
fn DrawPixelV*(position: Vector2, color: Color);
fn DrawLine*(startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color);
fn DrawLineV*(startPos: Vector2, endPos: Vector2, color: Color);
fn DrawLineEx*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color);
fn DrawLineStrip*(points: ^Vector2, pointCount: int32, color: Color);
fn DrawLineBezier*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color);
fn DrawCircle*(centerX: int32, centerY: int32, radius: real32, color: Color);
fn DrawCircleSector*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
fn DrawCircleSectorLines*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
fn DrawCircleGradient*(centerX: int32, centerY: int32, radius: real32, inner: Color, outer: Color);
fn DrawCircleV*(center: Vector2, radius: real32, color: Color);
fn DrawCircleLines*(centerX: int32, centerY: int32, radius: real32, color: Color);
fn DrawCircleLinesV*(center: Vector2, radius: real32, color: Color);
fn DrawEllipse*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color);
fn DrawEllipseLines*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color);
fn DrawRing*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
fn DrawRingLines*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color);
fn DrawRectangle*(posX: int32, posY: int32, width: int32, height: int32, color: Color);
fn DrawRectangleV*(position: Vector2, size: Vector2, color: Color);
fn DrawRectangleRec*(rec: Rectangle, color: Color);
fn DrawRectanglePro*(rec: Rectangle, origin: Vector2, rotation: real32, color: Color);
fn DrawRectangleGradientV*(posX: int32, posY: int32, width: int32, height: int32, top: Color, bottom: Color);
fn DrawRectangleGradientH*(posX: int32, posY: int32, width: int32, height: int32, left: Color, right: Color);
fn DrawRectangleGradientEx*(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color);
fn DrawRectangleLines*(posX: int32, posY: int32, width: int32, height: int32, color: Color);
fn DrawRectangleLinesEx*(rec: Rectangle, lineThick: real32, color: Color);
fn DrawRectangleRounded*(rec: Rectangle, roundness: real32, segments: int32, color: Color);
fn DrawRectangleRoundedLines*(rec: Rectangle, roundness: real32, segments: int32, color: Color);
fn DrawRectangleRoundedLinesEx*(rec: Rectangle, roundness: real32, segments: int32, lineThick: real32, color: Color);
fn DrawTriangle*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
fn DrawTriangleLines*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
fn DrawTriangleFan*(points: ^Vector2, pointCount: int32, color: Color);
fn DrawTriangleStrip*(points: ^Vector2, pointCount: int32, color: Color);
fn DrawPoly*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color);
fn DrawPolyLines*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color);
fn DrawPolyLinesEx*(center: Vector2, sides: int32, radius: real32, rotation: real32, lineThick: real32, color: Color);
fn DrawSplineLinear*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
fn DrawSplineBasis*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
fn DrawSplineCatmullRom*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
fn DrawSplineBezierQuadratic*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
fn DrawSplineBezierCubic*(points: ^Vector2, pointCount: int32, thick: real32, color: Color);
fn DrawSplineSegmentLinear*(p1: Vector2, p2: Vector2, thick: real32, color: Color);
fn DrawSplineSegmentBasis*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: real32, color: Color);
fn DrawSplineSegmentCatmullRom*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: real32, color: Color);
fn DrawSplineSegmentBezierQuadratic*(p1: Vector2, c2: Vector2, p3: Vector2, thick: real32, color: Color);
fn DrawSplineSegmentBezierCubic*(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: real32, color: Color);
fn GetSplinePointLinear*(startPos: Vector2, endPos: Vector2, t: real32): Vector2;
fn GetSplinePointBasis*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: real32): Vector2;
fn GetSplinePointCatmullRom*(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: real32): Vector2;
fn GetSplinePointBezierQuad*(p1: Vector2, c2: Vector2, p3: Vector2, t: real32): Vector2;
fn GetSplinePointBezierCubic*(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: real32): Vector2;
fn CheckCollisionRecs*(rec1: Rectangle, rec2: Rectangle): bool;
fn CheckCollisionCircles*(center1: Vector2, radius1: real32, center2: Vector2, radius2: real32): bool;
fn CheckCollisionCircleRec*(center: Vector2, radius: real32, rec: Rectangle): bool;
fn CheckCollisionCircleLine*(center: Vector2, radius: real32, p1: Vector2, p2: Vector2): bool;
fn CheckCollisionPointRec*(point: Vector2, rec: Rectangle): bool;
fn CheckCollisionPointCircle*(point: Vector2, center: Vector2, radius: real32): bool;
fn CheckCollisionPointTriangle*(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool;
fn CheckCollisionPointLine*(point: Vector2, p1: Vector2, p2: Vector2, threshold: int32): bool;
fn CheckCollisionPointPoly*(point: Vector2, points: ^Vector2, pointCount: int32): bool;
fn CheckCollisionLines*(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2): bool;
fn GetCollisionRec*(rec1: Rectangle, rec2: Rectangle): Rectangle;
fn LoadImage*(fileName: str): Image;
fn LoadImageRaw*(fileName: str, width: int32, height: int32, format: int32, headerSize: int32): Image;
fn LoadImageAnim*(fileName: str, frames: ^int32): Image;
fn LoadImageAnimFromMemory*(fileType: str, fileData: str, dataSize: int32, frames: ^int32): Image;
fn LoadImageFromMemory*(fileType: str, fileData: str, dataSize: int32): Image;
fn LoadImageFromTexture*(texture: Texture2D): Image;
fn LoadImageFromScreen*(): Image;
fn IsImageValid*(image: Image): bool;
fn UnloadImage*(image: Image);
fn ExportImage*(image: Image, fileName: str): bool;
fn ExportImageToMemory*(image: Image, fileType: str, fileSize: ^int32): str;
fn ExportImageAsCode*(image: Image, fileName: str): bool;
fn GenImageColor*(width: int32, height: int32, color: Color): Image;
fn GenImageGradientLinear*(width: int32, height: int32, direction: int32, start: Color, end: Color): Image;
fn GenImageGradientRadial*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image;
fn GenImageGradientSquare*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image;
fn GenImageChecked*(width: int32, height: int32, checksX: int32, checksY: int32, col1: Color, col2: Color): Image;
fn GenImageWhiteNoise*(width: int32, height: int32, factor: real32): Image;
fn GenImagePerlinNoise*(width: int32, height: int32, offsetX: int32, offsetY: int32, scale: real32): Image;
fn GenImageCellular*(width: int32, height: int32, tileSize: int32): Image;
fn GenImageText*(width: int32, height: int32, text: str): Image;
fn ImageCopy*(image: Image): Image;
fn ImageFromImage*(image: Image, rec: Rectangle): Image;
fn ImageFromChannel*(image: Image, selectedChannel: int32): Image;
fn ImageText*(text: str, fontSize: int32, color: Color): Image;
fn ImageTextEx*(font: Font, text: str, fontSize: real32, spacing: real32, tint: Color): Image;
fn ImageFormat*(image: ^Image, newFormat: int32);
fn ImageToPOT*(image: ^Image, fill: Color);
fn ImageCrop*(image: ^Image, crop: Rectangle);
fn ImageAlphaCrop*(image: ^Image, threshold: real32);
fn ImageAlphaClear*(image: ^Image, color: Color, threshold: real32);
fn ImageAlphaMask*(image: ^Image, alphaMask: Image);
fn ImageAlphaPremultiply*(image: ^Image);
fn ImageBlurGaussian*(image: ^Image, blurSize: int32);
fn ImageKernelConvolution*(image: ^Image, kernel: ^real32, kernelSize: int32);
fn ImageResize*(image: ^Image, newWidth: int32, newHeight: int32);
fn ImageResizeNN*(image: ^Image, newWidth: int32, newHeight: int32);
fn ImageResizeCanvas*(image: ^Image, newWidth: int32, newHeight: int32, offsetX: int32, offsetY: int32, fill: Color);
fn ImageMipmaps*(image: ^Image);
fn ImageDither*(image: ^Image, rBpp: int32, gBpp: int32, bBpp: int32, aBpp: int32);
fn ImageFlipVertical*(image: ^Image);
fn ImageFlipHorizontal*(image: ^Image);
fn ImageRotate*(image: ^Image, degrees: int32);
fn ImageRotateCW*(image: ^Image);
fn ImageRotateCCW*(image: ^Image);
fn ImageColorTint*(image: ^Image, color: Color);
fn ImageColorInvert*(image: ^Image);
fn ImageColorGrayscale*(image: ^Image);
fn ImageColorContrast*(image: ^Image, contrast: real32);
fn ImageColorBrightness*(image: ^Image, brightness: int32);
fn ImageColorReplace*(image: ^Image, color: Color, replace: Color);
fn LoadImageColors*(image: Image): ^Color;
fn LoadImagePalette*(image: Image, maxPaletteSize: int32, colorCount: ^int32): ^Color;
fn UnloadImageColors*(colors: ^Color);
fn UnloadImagePalette*(colors: ^Color);
fn GetImageAlphaBorder*(image: Image, threshold: real32): Rectangle;
fn GetImageColor*(image: Image, x: int32, y: int32): Color;
fn ImageClearBackground*(dst: ^Image, color: Color);
fn ImageDrawPixel*(dst: ^Image, posX: int32, posY: int32, color: Color);
fn ImageDrawPixelV*(dst: ^Image, position: Vector2, color: Color);
fn ImageDrawLine*(dst: ^Image, startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color);
fn ImageDrawLineV*(dst: ^Image, start: Vector2, end: Vector2, color: Color);
fn ImageDrawLineEx*(dst: ^Image, start: Vector2, end: Vector2, thick: int32, color: Color);
fn ImageDrawCircle*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color);
fn ImageDrawCircleV*(dst: ^Image, center: Vector2, radius: int32, color: Color);
fn ImageDrawCircleLines*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color);
fn ImageDrawCircleLinesV*(dst: ^Image, center: Vector2, radius: int32, color: Color);
fn ImageDrawRectangle*(dst: ^Image, posX: int32, posY: int32, width: int32, height: int32, color: Color);
fn ImageDrawRectangleV*(dst: ^Image, position: Vector2, size: Vector2, color: Color);
fn ImageDrawRectangleRec*(dst: ^Image, rec: Rectangle, color: Color);
fn ImageDrawRectangleLines*(dst: ^Image, rec: Rectangle, thick: int32, color: Color);
fn ImageDrawTriangle*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
fn ImageDrawTriangleEx*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color);
fn ImageDrawTriangleLines*(dst: ^Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
fn ImageDrawTriangleFan*(dst: ^Image, points: ^Vector2, pointCount: int32, color: Color);
fn ImageDrawTriangleStrip*(dst: ^Image, points: ^Vector2, pointCount: int32, color: Color);
fn ImageDraw*(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color);
fn ImageDrawText*(dst: ^Image, text: str, posX: int32, posY: int32, fontSize: int32, color: Color);
fn ImageDrawTextEx*(dst: ^Image, font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
fn LoadTexture*(fileName: str): Texture2D;
fn LoadTextureFromImage*(image: Image): Texture2D;
fn LoadTextureCubemap*(image: Image, layout: int32): TextureCubemap;
fn LoadRenderTexture*(width: int32, height: int32): RenderTexture2D;
fn IsTextureValid*(texture: Texture2D): bool;
fn UnloadTexture*(texture: Texture2D);
fn IsRenderTextureValid*(target: RenderTexture2D): bool;
fn UnloadRenderTexture*(target: RenderTexture2D);
fn UpdateTexture*(texture: Texture2D, pixels: ^void);
fn UpdateTextureRec*(texture: Texture2D, rec: Rectangle, pixels: ^void);
fn GenTextureMipmaps*(texture: ^Texture2D);
fn SetTextureFilter*(texture: Texture2D, filter: int32);
fn SetTextureWrap*(texture: Texture2D, wrap: int32);
fn DrawTexture*(texture: Texture2D, posX: int32, posY: int32, tint: Color);
fn DrawTextureV*(texture: Texture2D, position: Vector2, tint: Color);
fn DrawTextureEx*(texture: Texture2D, position: Vector2, rotation: real32, scale: real32, tint: Color);
fn DrawTextureRec*(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color);
fn DrawTexturePro*(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color);
fn DrawTextureNPatch*(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color);
fn ColorIsEqual*(col1: Color, col2: Color): bool;
fn Fade*(color: Color, alpha: real32): Color;
fn ColorToInt*(color: Color): int32;
fn ColorNormalize*(color: Color): Vector4;
fn ColorFromNormalized*(normalized: Vector4): Color;
fn ColorToHSV*(color: Color): Vector3;
fn ColorFromHSV*(hue: real32, saturation: real32, value: real32): Color;
fn ColorTint*(color: Color, tint: Color): Color;
fn ColorBrightness*(color: Color, factor: real32): Color;
fn ColorContrast*(color: Color, contrast: real32): Color;
fn ColorAlpha*(color: Color, alpha: real32): Color;
fn ColorAlphaBlend*(dst: Color, src: Color, tint: Color): Color;
fn ColorLerp*(color1: Color, color2: Color, factor: real32): Color;
fn GetColor*(hexValue: uint32): Color;
fn GetPixelColor*(srcPtr: ^void, format: int32): Color;
fn SetPixelColor*(dstPtr: ^void, color: Color, format: int32);
fn GetPixelDataSize*(width: int32, height: int32, format: int32): int32;
fn GetFontDefault*(): Font;
fn LoadFont*(fileName: str): Font;
fn LoadFontEx*(fileName: str, fontSize: int32, codepoints: ^int32, codepointCount: int32): Font;
fn LoadFontFromImage*(image: Image, key: Color, firstChar: int32): Font;
fn LoadFontFromMemory*(fileType: str, fileData: str, dataSize: int32, fontSize: int32, codepoints: ^int32, codepointCount: int32): Font;
fn IsFontValid*(font: Font): bool;
fn LoadFontData*(fileData: str, dataSize: int32, fontSize: int32, codepoints: ^int32, codepointCount: int32, __type: int32): ^GlyphInfo;
fn GenImageFontAtlas*(glyphs: ^GlyphInfo, glyphRecs: ^^Rectangle, glyphCount: int32, fontSize: int32, padding: int32, packMethod: int32): Image;
fn UnloadFontData*(glyphs: ^GlyphInfo, glyphCount: int32);
fn UnloadFont*(font: Font);
fn ExportFontAsCode*(font: Font, fileName: str): bool;
fn DrawFPS*(posX: int32, posY: int32);
fn DrawText*(text: str, posX: int32, posY: int32, fontSize: int32, color: Color);
fn DrawTextEx*(font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
fn DrawTextPro*(font: Font, text: str, position: Vector2, origin: Vector2, rotation: real32, fontSize: real32, spacing: real32, tint: Color);
fn DrawTextCodepoint*(font: Font, codepoint: int32, position: Vector2, fontSize: real32, tint: Color);
fn DrawTextCodepoints*(font: Font, codepoints: ^int32, codepointCount: int32, position: Vector2, fontSize: real32, spacing: real32, tint: Color);
fn SetTextLineSpacing*(spacing: int32);
fn MeasureText*(text: str, fontSize: int32): int32;
fn MeasureTextEx*(font: Font, text: str, fontSize: real32, spacing: real32): Vector2;
fn GetGlyphIndex*(font: Font, codepoint: int32): int32;
fn GetGlyphInfo*(font: Font, codepoint: int32): GlyphInfo;
fn GetGlyphAtlasRec*(font: Font, codepoint: int32): Rectangle;
fn LoadUTF8*(codepoints: ^int32, length: int32): str;
fn UnloadUTF8*(text: str);
fn LoadCodepoints*(text: str, count: ^int32): ^int32;
fn UnloadCodepoints*(codepoints: ^int32);
fn GetCodepointCount*(text: str): int32;
fn GetCodepoint*(text: str, codepointSize: ^int32): int32;
fn GetCodepointNext*(text: str, codepointSize: ^int32): int32;
fn GetCodepointPrevious*(text: str, codepointSize: ^int32): int32;
fn CodepointToUTF8*(codepoint: int32, utf8Size: ^int32): str;
fn TextCopy*(dst: str, src: str): int32;
fn TextIsEqual*(text1: str, text2: str): bool;
fn TextLength*(text: str): uint32;
fn TextSubtext*(text: str, position: int32, length: int32): str;
fn TextReplace*(text: str, replace: str, by: str): str;
fn TextInsert*(text: str, insert: str, position: int32): str;
fn TextJoin*(textList: ^str, count: int32, delimiter: str): str;
fn TextSplit*(text: str, delimiter: int8, count: ^int32): ^str;
fn TextAppend*(text: str, append: str, position: ^int32);
fn TextFindIndex*(text: str, find: str): int32;
fn TextToUpper*(text: str): str;
fn TextToLower*(text: str): str;
fn TextToPascal*(text: str): str;
fn TextToSnake*(text: str): str;
fn TextToCamel*(text: str): str;
fn TextToInteger*(text: str): int32;
fn TextToFloat*(text: str): real32;
fn DrawLine3D*(startPos: Vector3, endPos: Vector3, color: Color);
fn DrawPoint3D*(position: Vector3, color: Color);
fn DrawCircle3D*(center: Vector3, radius: real32, rotationAxis: Vector3, rotationAngle: real32, color: Color);
fn DrawTriangle3D*(v1: Vector3, v2: Vector3, v3: Vector3, color: Color);
fn DrawTriangleStrip3D*(points: ^Vector3, pointCount: int32, color: Color);
fn DrawCube*(position: Vector3, width: real32, height: real32, length: real32, color: Color);
fn DrawCubeV*(position: Vector3, size: Vector3, color: Color);
fn DrawCubeWires*(position: Vector3, width: real32, height: real32, length: real32, color: Color);
fn DrawCubeWiresV*(position: Vector3, size: Vector3, color: Color);
fn DrawSphere*(centerPos: Vector3, radius: real32, color: Color);
fn DrawSphereEx*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color);
fn DrawSphereWires*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color);
fn DrawCylinder*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color);
fn DrawCylinderEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color);
fn DrawCylinderWires*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color);
fn DrawCylinderWiresEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color);
fn DrawCapsule*(startPos: Vector3, endPos: Vector3, radius: real32, slices: int32, rings: int32, color: Color);
fn DrawCapsuleWires*(startPos: Vector3, endPos: Vector3, radius: real32, slices: int32, rings: int32, color: Color);
fn DrawPlane*(centerPos: Vector3, size: Vector2, color: Color);
fn DrawRay*(ray: Ray, color: Color);
fn DrawGrid*(slices: int32, spacing: real32);
fn LoadModel*(fileName: str): Model;
fn LoadModelFromMesh*(mesh: Mesh): Model;
fn IsModelValid*(model: Model): bool;
fn UnloadModel*(model: Model);
fn GetModelBoundingBox*(model: Model): BoundingBox;
fn DrawModel*(model: Model, position: Vector3, scale: real32, tint: Color);
fn DrawModelEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
fn DrawModelWires*(model: Model, position: Vector3, scale: real32, tint: Color);
fn DrawModelWiresEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
fn DrawModelPoints*(model: Model, position: Vector3, scale: real32, tint: Color);
fn DrawModelPointsEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color);
fn DrawBoundingBox*(box: BoundingBox, color: Color);
fn DrawBillboard*(camera: Camera, texture: Texture2D, position: Vector3, scale: real32, tint: Color);
fn DrawBillboardRec*(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color);
fn DrawBillboardPro*(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: real32, tint: Color);
fn UploadMesh*(mesh: ^Mesh, dynamic: bool);
fn UpdateMeshBuffer*(mesh: Mesh, index: int32, data: ^void, dataSize: int32, offset: int32);
fn UnloadMesh*(mesh: Mesh);
fn DrawMesh*(mesh: Mesh, material: Material, transform: Matrix);
fn DrawMeshInstanced*(mesh: Mesh, material: Material, transforms: ^Matrix, instances: int32);
fn GetMeshBoundingBox*(mesh: Mesh): BoundingBox;
fn GenMeshTangents*(mesh: ^Mesh);
fn ExportMesh*(mesh: Mesh, fileName: str): bool;
fn ExportMeshAsCode*(mesh: Mesh, fileName: str): bool;
fn GenMeshPoly*(sides: int32, radius: real32): Mesh;
fn GenMeshPlane*(width: real32, length: real32, resX: int32, resZ: int32): Mesh;
fn GenMeshCube*(width: real32, height: real32, length: real32): Mesh;
fn GenMeshSphere*(radius: real32, rings: int32, slices: int32): Mesh;
fn GenMeshHemiSphere*(radius: real32, rings: int32, slices: int32): Mesh;
fn GenMeshCylinder*(radius: real32, height: real32, slices: int32): Mesh;
fn GenMeshCone*(radius: real32, height: real32, slices: int32): Mesh;
fn GenMeshTorus*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh;
fn GenMeshKnot*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh;
fn GenMeshHeightmap*(heightmap: Image, size: Vector3): Mesh;
fn GenMeshCubicmap*(cubicmap: Image, cubeSize: Vector3): Mesh;
fn LoadMaterials*(fileName: str, materialCount: ^int32): ^Material;
fn LoadMaterialDefault*(): Material;
fn IsMaterialValid*(material: Material): bool;
fn UnloadMaterial*(material: Material);
fn SetMaterialTexture*(material: ^Material, mapType: int32, texture: Texture2D);
fn SetModelMeshMaterial*(model: ^Model, meshId: int32, materialId: int32);
fn LoadModelAnimations*(fileName: str, animCount: ^int32): ^ModelAnimation;
fn UpdateModelAnimation*(model: Model, anim: ModelAnimation, frame: int32);
fn UpdateModelAnimationBones*(model: Model, anim: ModelAnimation, frame: int32);
fn UnloadModelAnimation*(anim: ModelAnimation);
fn UnloadModelAnimations*(animations: ^ModelAnimation, animCount: int32);
fn IsModelAnimationValid*(model: Model, anim: ModelAnimation): bool;
fn CheckCollisionSpheres*(center1: Vector3, radius1: real32, center2: Vector3, radius2: real32): bool;
fn CheckCollisionBoxes*(box1: BoundingBox, box2: BoundingBox): bool;
fn CheckCollisionBoxSphere*(box: BoundingBox, center: Vector3, radius: real32): bool;
fn GetRayCollisionSphere*(ray: Ray, center: Vector3, radius: real32): RayCollision;
fn GetRayCollisionBox*(ray: Ray, box: BoundingBox): RayCollision;
fn GetRayCollisionMesh*(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision;
fn GetRayCollisionTriangle*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision;
fn GetRayCollisionQuad*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision;
fn InitAudioDevice*();
fn CloseAudioDevice*();
fn IsAudioDeviceReady*(): bool;
fn SetMasterVolume*(volume: real32);
fn GetMasterVolume*(): real32;
fn LoadWave*(fileName: str): Wave;
fn LoadWaveFromMemory*(fileType: str, fileData: str, dataSize: int32): Wave;
fn IsWaveValid*(wave: Wave): bool;
fn LoadSound*(fileName: str): Sound;
fn LoadSoundFromWave*(wave: Wave): Sound;
fn LoadSoundAlias*(source: Sound): Sound;
fn IsSoundValid*(sound: Sound): bool;
fn UpdateSound*(sound: Sound, data: ^void, sampleCount: int32);
fn UnloadWave*(wave: Wave);
fn UnloadSound*(sound: Sound);
fn UnloadSoundAlias*(alias: Sound);
fn ExportWave*(wave: Wave, fileName: str): bool;
fn ExportWaveAsCode*(wave: Wave, fileName: str): bool;
fn PlaySound*(sound: Sound);
fn StopSound*(sound: Sound);
fn PauseSound*(sound: Sound);
fn ResumeSound*(sound: Sound);
fn IsSoundPlaying*(sound: Sound): bool;
fn SetSoundVolume*(sound: Sound, volume: real32);
fn SetSoundPitch*(sound: Sound, pitch: real32);
fn SetSoundPan*(sound: Sound, pan: real32);
fn WaveCopy*(wave: Wave): Wave;
fn WaveCrop*(wave: ^Wave, initFrame: int32, finalFrame: int32);
fn WaveFormat*(wave: ^Wave, sampleRate: int32, sampleSize: int32, channels: int32);
fn LoadWaveSamples*(wave: Wave): ^real32;
fn UnloadWaveSamples*(samples: ^real32);
fn LoadMusicStream*(fileName: str): Music;
fn LoadMusicStreamFromMemory*(fileType: str, data: str, dataSize: int32): Music;
fn IsMusicValid*(music: Music): bool;
fn UnloadMusicStream*(music: Music);
fn PlayMusicStream*(music: Music);
fn IsMusicStreamPlaying*(music: Music): bool;
fn UpdateMusicStream*(music: Music);
fn StopMusicStream*(music: Music);
fn PauseMusicStream*(music: Music);
fn ResumeMusicStream*(music: Music);
fn SeekMusicStream*(music: Music, position: real32);
fn SetMusicVolume*(music: Music, volume: real32);
fn SetMusicPitch*(music: Music, pitch: real32);
fn SetMusicPan*(music: Music, pan: real32);
fn GetMusicTimeLength*(music: Music): real32;
fn GetMusicTimePlayed*(music: Music): real32;
fn LoadAudioStream*(sampleRate: uint32, sampleSize: uint32, channels: uint32): AudioStream;
fn IsAudioStreamValid*(stream: AudioStream): bool;
fn UnloadAudioStream*(stream: AudioStream);
fn UpdateAudioStream*(stream: AudioStream, data: ^void, frameCount: int32);
fn IsAudioStreamProcessed*(stream: AudioStream): bool;
fn PlayAudioStream*(stream: AudioStream);
fn PauseAudioStream*(stream: AudioStream);
fn ResumeAudioStream*(stream: AudioStream);
fn IsAudioStreamPlaying*(stream: AudioStream): bool;
fn StopAudioStream*(stream: AudioStream);
fn SetAudioStreamVolume*(stream: AudioStream, volume: real32);
fn SetAudioStreamPitch*(stream: AudioStream, pitch: real32);
fn SetAudioStreamPan*(stream: AudioStream, pan: real32);
fn SetAudioStreamBufferSizeDefault*(size: int32);
